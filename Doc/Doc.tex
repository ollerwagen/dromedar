\documentclass{article}

\usepackage{listings, xcolor, enumitem, hyperref, multicol, booktabs, longtable, titlesec, amssymb, amsmath}

\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}

\usepackage[margin=2cm,a4paper]{geometry}

\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\lstdefinelanguage{Dromedar}{
	morekeywords = [1]{int,flt,char,bool,void,fn},
	morekeywords = [2]{true,false},
	morekeywords = [3]{return,if,else,while,do},
	morekeywords = [4]{},
	comment = [l]{\#},
	%morecomment = [s]{/*}{*/},
	string = [b]',
	morestring = [b]"
}

\lstset{
	language=Dromedar,
	nolol=false,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	xleftmargin=\parindent,
	framexleftmargin=0.2em,
	belowskip=0.6em,
	%basewidth=0.5em,
	backgroundcolor=\color{white!90!black},
	emphstyle=\bfseries\slshape,
	basicstyle=\ttfamily\color{black},
	keywordstyle=\bfseries,
	commentstyle=\color{gray},
	stringstyle=\slshape,
	showstringspaces=false,
	tabsize=4
}

\renewcommand{\c}[1]{\texttt{#1}}
\newcommand{\code}[1]{\lstinline[columns=fixed]{#1}}

\newcommand{\drmrule}[5]{\frac{#1}{#2\vdash_{\mathsf{#3}}#4}\textsc{\small{#5}}}

\newcommand{\parw}{9cm}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\subsubsubsection}{\paragraph}

\begin{document}
	
	\vfill
	\begin{center}
		\large{Oliver Graf}\\
		\vspace{5cm}
		\large{\textsc{The}}\\\vspace{1cm}
		\Huge{\textsc{Dromedar}}\\\vspace{1cm}
		\large{\textsc{Programming Language}}
	\end{center}
	\vfill
	
	\clearpage
	
	\setcounter{tocdepth}{1}
	\tableofcontents
	\clearpage
	
	\section{Introduction}
	
	\section{Typing System}
	
		Dromedar uses a static, strong and sound typing system -- typing errors cannot happen at runtime. It knows primitive and reference types.
		
		\subsection{Primitives}
		
			There are four primitive types:
			
			\begin{itemize}
				\item \code{int} represents 64-bit 2's complement (signed) integers.
				\item \code{flt} represents 64-bit IEEE-754 standard floating point numbers.
				\item \code{char} represents 8-bit UTF-8 characters.
				\item \code{bool} represents a 1-bit value: \code{true} and \code{false}.
			\end{itemize}
		
		\subsection{Reference Types}
		
			Reference Types of type \code{t} come in two shapes: \code{t}, a strictly non-\code{null} reference; and \code{t?}, a reference that may be \code{null}, where \code{t} is considered a subtype of \code{t?}.
			
			Splitting up references that way has two advantages: On one hand, it enforces a good coding style and helps find Null pointer bugs before they even appear; on the other hand it accelerates the execution environment by allowing it to skip Null checks when dereferencing an object if it is of a strictly non-\code{null} type.
		
	\section{Expressions}
	
		Because Dromedar has a strong type system, it generally disallows any operations with operands of a non-specified type unless they are explicitly cast to the correct type before. This means that integer and floating point numbers cannot be added, multiplied, etc.
		
		The following table describes precedence and type of all operators:\\
		
		\begin{tabular}{l|l|c|l|l}
			\textbf{Operator} & \textbf{Name} & \textbf{Prec.} & \textbf{Assoc.} & \textbf{Types}\\
			\midrule
			\code{-} & Unary Negation & 100 & non-assoc. & \code{int -> int}\\
				&&&& \code{flt -> flt}\\
			\code{!} & Logical Negation &&& \code{bool -> bool}\\
			\midrule
			\code{**} & Exponentiation & 90 & right & \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
			\midrule
			\code{*} & Multiplication & 80 & left & \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
			\midrule
			\code{+},\code{-} & Addition & 70 & left & \code{int,int -> int}\\
				& Subtraction &&& \code{flt,flt -> flt}\\
				&&&& \code{char,int -> char}\\
				&&&& \code{int,char -> char}\\
			\midrule
			\code{<<},\code{>>},\code{>>>} & Left Shift & 60 & left & \code{int,int -> int}\\
			& Logical Right Shift &&& \\
			& Arithmetic Right Shift &&& \\
			\midrule
			\code{\&} & Bitwise And & 60 & left & \code{int,int -> int}\\
			\midrule
			\code{\^} & Bitwise Xor & 50 & left & \code{int,int -> int}\\
			\midrule
			\code{|} & Bitwise Or & 40 & left & \code{int,int -> int}\\
			\midrule
			\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=} & Comparison & 30 & non-assoc. & \code{[int] -> bool} \\
				&&&& \code{[flt] -> bool}\\
			\midrule
			\code{\&\&} & Logical And & 20 & left & \code{bool,bool -> bool}\\
			\midrule
			\code{||} & Logical Or & 10 & left & \code{bool,bool -> bool}
		\end{tabular}\\
	
		Consider the following example:
		
		The expression \code{1+18-18+'a'} is well-typed (of type \code{char}) and gets parsed as \code{((1+18)-18)+'a'} and evaluated to \code{'b'}. \code{10 - 0.0} on the other hand is not well-typed as \code{-} cannot take an \code{int} and a \code{flt} operand as arguments.
		
		Comparison operators work differently to other (binary) operators: Instead of comparing just two expressions, Dromedar allows chaining expressions to create one final boolean value: For example, \code{1 < 2 != 5 >= 5} holds because every single sub-expression (\code{1 < 2}, \code{2 != 5} and \code{5 >= 5}) holds. Every expression is only evaluated once for its side-effect.
		
		Thus, \code{A op B op C} is not necessarily semantically equivalent to \code{A op B \&\& B op C}.
		
	\section{Handling Whitespace}
	
		In order to keep the code simple and easy to look at, Dromedar uses significant whitespace: Blocks of code (such as bodies of \code{if}) statements, are denoted by adding a level of indentation.
		
		Every line is either empty (this includes lines containing only comments), or it contains code. 
		
		If a line contains code, the level of its indentation is determined by its relationship to the previous line and its environment:
		
		Two neighboring lines of code within the same block of code must have exactly matching whitespace characters before their respective code starts. If a following line has a deeper level of indentation, it must match the whitespace characters of the previous line and then add a number of additional whitespace characters (space(s) and/or tab(s)).
		
		A line of code can only have a deeper indentation level of one step compared to the previous line. The first line of code is always a global instruction and as such has the lowest level of indentation. If it is indented, this level of indentation corresponds to a baseline indentation that every line of code must share.
		
		Consider this valid example:
		
		\begin{lstlisting}
  global x := 3 		# baseline indentation of two spaces
						# empty line -> indentation doesn't matter
  fn main : args:[string] -> int
  			Stdio.println("Hello, World!")	# deeper indentation level
  			return 0						# same indentation level
		\end{lstlisting}
		
		Blocks with the same level of indentation can have different indentation strings, but they must still match their environments, as follows:
		
		\begin{lstlisting}
		if <condition>
				BLOCK A
		else
		  BLOCK B
		\end{lstlisting}
		
		The two blocks have a different indentation level, but from context it is still clear that \code{BLOCK A} is a sub-block of the \code{if}-statement, whereas \code{BLOCK B} belongs to the \code{else}-statement.
		
	\section{Buildup of a Program}
	
		A program consists of a series of global statements -- global variable declarations and function definitions.
		
		\subsection{Global Declarations}
		
			Global variables are all assigned a value at the point of their declaration. This value is evaluated statically -- declaration expressions can only contain literals and global variables that were already declared previously.
			
			Functions are also declared globally.
		
	\section{Formal Typing Rules}
	
		A typing rule takes the following shape: $$ \drmrule{\mathrm{Hypotheses}}{S,\dots}{}{\textnormal{\code{grammar spec}}}{name} $$
		
		Here, $S$ represents a stack of symbol definitions: $S \in (\mathsf{id} \times \mathsf{type})^n$ for some block depth $n$ at any given point. In global context, $S$ has only one layer. $\mathsf{id}$ corresponds to the set of names that variables can have (related to the Lexer symbol \texttt{\%Identifier}), and $\mathsf{type}$ to the set of types in a given program (related to the Parser symbol \texttt{Type}).
		
		The symbol $\in$ is defined as follows: $s\in S \Leftrightarrow \textnormal{$s$ is contained in \textit{any} layer of $S$}$, whereas $\in_0$ is true only if the symbol is at the top level of the symbol stack (i.e. defined in the same block). The operator $\cup$ on $S$ adds another binding to the top layer of the stack, whereas $\sqcup$ adds another layer to the stack.
		
		The following are the typing rules for Dromedar programs:
		
		\subsection{Builtin Operators}
		
			Many builtin operators are overloaded, providing functionality for multiple input types.
			
			\subsubsection{Unary Operators}
			
				\subsubsubsection{Arithmetic Negation}
				
					\begin{align*}
						\drmrule{}{}{O}{\textnormal{\code{-}} :: \mathsf{int \to int}}{TyUopNeg},\ \ 
						\drmrule{}{}{O}{\textnormal{\code{-}} :: \mathsf{flt \to flt}}{TyUopNeg}
					\end{align*}
				
				\subsubsubsection{Logical Negation}

					\begin{align*}
						\drmrule{}{}{O}{\textnormal{\code{!}} :: \mathsf{bool \to bool}}{TyUopNot}
					\end{align*}
			
			\subsubsection{Binary Operators}
			
				\subsubsubsection{Power}
				
					\begin{align*}
						\drmrule{}{}{O}{\textnormal{\code{**}} :: \mathsf{(int,int) \to int}}{TyBopPow},\ \ 
						\drmrule{}{}{O}{\textnormal{\code{**}} :: \mathsf{(flt,flt) \to flt}}{tyBopPow}
					\end{align*}
				
				\subsubsubsection{Multiplication}
				
					\begin{align*}
						\drmrule{}{}{O}{\textnormal{\code{*}} :: \mathsf{(int,int) \to int}}{TyBopMul},\ \ 
						\drmrule{}{}{O}{\textnormal{\code{*}} :: \mathsf{(flt,flt) \to flt}}{TyBopMul}
					\end{align*}
				
				\subsubsubsection{Addition and Subtraction}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{+}} :: \mathsf{(int,int) \to int}}{TyBopAdd},\ \ &
								\drmrule{}{}{O}{\textnormal{\code{+}} :: \mathsf{(flt,flt) \to flt}}{TyBopAdd},\\
								\drmrule{}{}{O}{\textnormal{\code{+}} :: \mathsf{(int,char) \to char}}{TyBopAdd},\ \ &
								\drmrule{}{}{O}{\textnormal{\code{+}} :: \mathsf{(char,int) \to char}}{TyBopAdd}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{-}} :: \mathsf{(int,int) \to int}}{TyBopSub},\ \ &
								\drmrule{}{}{O}{\textnormal{\code{-}} :: \mathsf{(flt,flt) \to flt}}{TyBopSub},\\
								\drmrule{}{}{O}{\textnormal{\code{-}} :: \mathsf{(int,char) \to char}}{TyBopSub},\ \ &
								\drmrule{}{}{O}{\textnormal{\code{-}} :: \mathsf{(char,int) \to char}}{TyBopSub}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Shift Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{<<}} :: \mathsf{(int,int) \to int}}{TyBopLShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{>>}} :: \mathsf{(int,int) \to int}}{TyBopBitRShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{>>>}} :: \mathsf{(int,int) \to int}}{TyBopBitAShift}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Bitwise Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{\&}} :: \mathsf{(int,int) \to int}}{TyBopBitAnd}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{^}} :: \mathsf{(int,int) \to int}}{TyBopXor},\ \ &
								\drmrule{}{}{O}{\textnormal{\code{^}} :: \mathsf{(bool,bool) \to bool}}{TyBopXor}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{|}} :: \mathsf{(int,int) \to int}}{TyBopBitOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Logical Operators}
				
					\begin{itemize}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{\&\&}} :: \mathsf{(bool,bool) \to bool}}{TyBopLogAnd}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\textnormal{\code{||}} :: \mathsf{(bool,bool) \to bool}}{TyBopLogOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Comparison Operators}
				
					\begin{align*}
						\drmrule{}{}{O}{\{\textnormal{\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=}}\} :: \mathsf{[int] \to bool}}{TyCmpList},\ \ &
						\drmrule{}{}{O}{\{\textnormal{\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=}}\} :: \mathsf{[flt] \to bool}}{TyCmpList},\\
						\drmrule{}{}{O}{\{\textnormal{\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=}}\} :: \mathsf{[char] \to bool}}{TyCmpList},\ \ &
					\end{align*}
					
					
		\subsection{Expressions}
		
			\subsubsection{Assignability}
			
				The rule $\vdash_A$ defines when an expression can be assigned a value.
				
				\begin{align*}
					\frac{(\textnormal{\code{id}},\mathsf{t})\in S}{S\vdash_A\textnormal{\code{id}}}\textsc{\small{ExpAssn}}
				\end{align*}
				
			\subsubsection{Global Expressions}
			
				The rule $\vdash_G$ describes global expressions, which are restricted in a way that they can be computed at compile time.
				
				Copied rules always use $\vdash_G$ instead of $\vdash_E$
				
				\subsubsubsection{Literals}
				
					\begin{itemize}
						\item \textsc{GExpLitInt} $:=$ \textsc{ExpLitInt}
						\item \textsc{GExpLitFlt} $:=$ \textsc{ExpLitFlt}
						\item \textsc{GExpLitChar} $:=$ \textsc{ExpLitChar}
						\item \textsc{GExpLitBool} $:=$ \textsc{ExpLitBool}
					\end{itemize}
				
				\subsubsubsection{Other Rules}
				
					\begin{itemize}
						\item \textsc{GExpId} $:=$ \textsc{ExpId}
						\item \textsc{GExpUop} $:=$ \textsc{ExpUop}
						\item \textsc{GExpBop} $:=$ \textsc{ExpBop}
						\item \textsc{GExpCmpList} $:=$ \textsc{ExpCmpList}
					\end{itemize}
				
					Note that global variable declarations cannot feature function calls.
		
			\subsubsection{Literals}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{}{}{E}{n :: \textnormal{\code{int}}}{ExpLitInt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{f :: \textnormal{\code{flt}}}{ExpLitFlt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{c :: \textnormal{\code{char}}}{ExpLitChar}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{\textnormal{\code{true}} :: \textnormal{\code{bool}}}{ExpLitBool},\ \ 
							\drmrule{}{}{E}{\textnormal{\code{true}} :: \textnormal{\code{bool}}}{ExpLitBool}
						\end{align*}
				\end{itemize}
			
			\subsubsection{Identifiers}
			
				\begin{align*}
					\drmrule{(id,\mathsf{t})\in S}{S}{E}{\textnormal{\code{id}} :: \mathsf{t}}{ExpId}
				\end{align*}
			
			\subsubsection{Unary Operations}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{exp}} :: \mathsf{t'}\ \ S\vdash\textnormal{\code{op}} :: \mathsf{t' \to t}}{S}{E}{\textnormal{\code{op exp}} :: \mathsf{t}}{ExpUop}
				\end{align*}
			
			\subsubsection{Binary Operations}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{e1}} :: \mathsf{t1}\ \ S\vdash\textnormal{\code{e2}} :: \mathsf{t2}\ \ S\vdash\textnormal{\code{op}} :: \mathsf{(t1,t2) \to t}}{S}{E}{\textnormal{\code{e1 op e2}} :: \mathsf{t}}{ExpBop}
				\end{align*}
			
			\subsubsection{Function Calls}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{f}} :: \mathsf{(t1,...,tn) \to rt}\ \ S\vdash\textnormal{\code{e1}} :: \mathsf{t1},\ \dots,\ S\vdash\textnormal{\code{en}} :: \mathsf{tn}}{S}{E}{\textnormal{\code{f(e1,...,en)}} :: \mathsf{rt}}{ExpFunc}
				\end{align*}
			
			\subsubsection{Comparison Lists}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{e0}} :: \mathsf{t0},\ \dots,\ S\vdash\textnormal{\code{en}} :: \mathsf{tn}\ \ S\vdash\textnormal{\code{op1}} :: \mathsf{(t0,t1) \to t},\ \dots,\ S\vdash\textnormal{\code{opn}} :: \mathsf{(t(n-1),tn) \to t}}{S}{E}{\textnormal{\code{e0 op1 ... opn en}} :: \mathsf{t}}{ExpCmpList}
				\end{align*}
				
		\subsection{Statements}
		
			In the statement typing rules, a statement rule produces a tuple $(S,r)$ where $S$ stands for the newly updates context, and $r\in\{\bot,\top\}$, where $\bot$ means that a statement might not return and $\top$ means that a statement might return.
			
			To prevent potential mistakes, the typechecker prevents statements which are deemed unreachable at compile time. Logical operators like $\wedge$ operate as if $\bot\equiv0$ and $\top\equiv1$.
		
			\subsubsection{Local Variable Declarations}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{exp}} :: \mathsf{t}}{S,\mathsf{rt}}{S}{\textnormal{\code{let id := exp}} \Rightarrow (S \cup (\textnormal{\code{id}},\mathsf{t})),\bot}{StmtVDecl}
				\end{align*}
			
			\subsubsection{Assignments}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{exp}} :: \mathsf{t}\ \ S\vdash\textnormal{\code{lhs}} :: \mathsf{t}\ \ S\vdash_A\textnormal{\code{lhs}}}{S,\mathsf{rt}}{S}{\textnormal{\code{lhs := exp}} \Rightarrow S,\bot}{StmtAssn}
				\end{align*}
			
			\subsubsection{Expression Statements}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{exp}} :: \mathsf{t}}{S,\mathsf{rt}}{S}{\textnormal{\code{exp}} \Rightarrow S,\bot}{StmtExpr}
				\end{align*}
			
			\subsubsection{If Statements}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{c}} :: \textnormal{\code{bool}}\ \ S,\mathsf{rt}\vdash\textnormal{\code{b1}}\Rightarrow S_1,R_1\ \ S,\mathsf{rt}\vdash\textnormal{\code{b2}}\Rightarrow S_2,R_2}{S,\mathsf{rt}}{S}{\textnormal{\code{if c b1 else b2}} \Rightarrow S,R_1\wedge R_2}{StmtIf}
				\end{align*}
			
			\subsubsection{While Statements}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{c}} :: \textnormal{\code{bool}}\ \ S,\mathsf{rt}\vdash\textnormal{\code{b}}\Rightarrow S',R}{S,\mathsf{rt}}{S}{\textnormal{\code{while c b}} \Rightarrow S,\bot}{StmtWhile}
				\end{align*}
			
			\subsubsection{Do-While Statements}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{c}} :: \textnormal{\code{bool}}\ \ S,\mathsf{rt}\vdash\textnormal{\code{b}}\Rightarrow S',R}{S,\mathsf{rt}}{S}{\textnormal{\code{do b while c}} \Rightarrow S,R}{StmtDoWhile}
				\end{align*}
			
			\subsubsection{Return Statements}
			
				\begin{align*}
					\drmrule{S\vdash\textnormal{\code{exp}}::\mathsf{rt}}{S,\mathsf{rt}}{\textnormal{\code{return exp}} \Rightarrow S,\top}{StmtReturn},\ \ \drmrule{}{S,\textnormal{\code{void}}}{S}{\textnormal{\code{return}}\Rightarrow S,\top}{StmtReturn}
				\end{align*}
				
			\subsubsection{Blocks}
			
				\begin{align*}
					\drmrule{S\sqcup\{\},\mathsf{rt}\vdash\textnormal{\code{s1}} \Rightarrow S_1,\bot,\ \ S_1,\mathsf{rt}\vdash\textnormal{\code{s2}} \Rightarrow S_2,\bot,\ \dots,\ S_{n-1},\mathsf{rt}\vdash\textnormal{\code{sn}} \Rightarrow S_n,R}{S,\mathsf{rt}}{S}{\textnormal{\code{s1 ... sn}} \Rightarrow S_n,R}{StmtBlock}
				\end{align*}
		
		\subsection{Global Statements}
		
			\subsubsection{Global Function Declaration}
			
				\begin{align*}
					\drmrule{S\sqcup\{(\textnormal{\code{a1}},\textnormal{\code{t1}}),\dots,(\textnormal{\code{an}},\textnormal{\code{tn}})\},\textnormal{\code{rt}} \vdash \textnormal{\code{b}},\top}{S}{G}{\textnormal{\code{fn id : a1:t1, ..., an:tn -> rt b}} \Rightarrow S}{GStmtFDecl}
				\end{align*}
			
			\subsubsection{Global Variable Declaration}
			
				\begin{align*}
					\drmrule{(\textnormal{\code{id}},any) \not\in S\ \ S\vdash_G\textnormal{\code{exp}} :: \mathsf{t}}{S}{G}{\textnormal{\code{global id := exp}} \Rightarrow S\cup\{(\textnormal{\code{id}},\mathsf{t})\}}{GStmtVDecl}
				\end{align*}
			
			\subsubsection{Program}
			
				\begin{align*}
					\drmrule{S_0 \vdash \textnormal{\code{gs1}} \Rightarrow S_1,\ \dots,\ S_{n-1} \vdash \textnormal{\code{gsn}} \Rightarrow S_n}{S_0 := \{\} \sqcup \{\}}{G}{\textnormal{\code{gs1 ... gsn}} \Rightarrow S_n}{GStmtProgram}
				\end{align*}
				
		\subsection{Context Type-Checking}
		
			\subsubsection{Global Function Declaration}
			
				\begin{align*}
					\drmrule{(\textnormal{\code{id}},any) \not\in S}{S}{GCF}{\textnormal{\code{fn id : a1:t1, ..., an:tn -> rt b}} \Rightarrow S \cup (\textnormal{\code{id}}, (\textnormal{\code{t1}},\dots,\textnormal{\code{tn}}) \to \textnormal{\code{rt}})}{GStmtCtxtFDecl}
				\end{align*}\begin{align*}
					\drmrule{}{S}{GCF}{\textnormal{\code{let id := exp}} \Rightarrow S}{GStmtCtxtFDecl}
				\end{align*}
			
			\subsubsection{Program: Functions}
			
				\begin{align*}
					\drmrule{S_0 \vdash_{\mathsf{GCF}} \textnormal{\code{gs1}} \Rightarrow S_1,\ \dots,\ S_{n-1} \vdash_{\mathsf{GCF}} \textnormal{\code{gs(n-1)}} \Rightarrow S_n}{S_0}{GC}{\textnormal{\code{gs1 ... gsn}} \Rightarrow S_n}{GStmtCtxtFuncs}
				\end{align*}
			
			\subsubsection{Program}
			
				\begin{align*}
					\drmrule{\{\}\sqcup\{\} \vdash_{\mathsf{GCF}} \mathsf{prog} \Rightarrow S' \ \ S' \vdash_{\mathsf{G}} \mathsf{prog} \Rightarrow S}{}{G}{\mathsf{prog} \Rightarrow S}{Prog}
				\end{align*}
		
	\section{Formal Grammar}
	
		\subsection{Lexer Grammar}
		
			The Lexer Grammar is specified using \textbf{regular expressions}:
			
			\begin{verbatim}
				LiteralInt  ::= /[1-9]\d*/
				LiteralFlt  ::= /\d+\.\d+/
				LiteralChar ::= /'([^'\\]|(\\[\\nrt']))'/
				LiteralBool ::= /true|false/
				
				Identifier  ::= /[a-zA-Z][a-zA-Z0-9_]*/
				
				global      ::= /global/
				fn          ::= /fn/
				let         ::= /let/
				mut         ::= /mut/
				
				int         ::= /int/
				flt         ::= /flt/
				char        ::= /char/
				bool        ::= /bool/
				void        ::= /void/
				
				if          ::= /if/
				elif        ::= /elif/
				else        ::= /else/
				do          ::= /do/
				while       ::= /while/
				
				return      ::= /return/
				
				Dash        ::= /\-/
				Bang        ::= /!/
				Star        ::= /\*/
				Plus        ::= /\+/
				LShift      ::= /<</
				RShift      ::= />>/
				AShift      ::= />>>/
				Bitand      ::= /&/
				Xor         ::= /\^/
				Bitor       ::= /\|/
				Logand      ::= /&&/
				Logor       ::= /\|\|/
				
				Equal       ::= /=/
				NotEqual    ::= /!=/
				Greater     ::= />/
				Less        ::= /</
				GreaterEq   ::= />=/
				LessEq      ::= /<=/
				
				Assign      ::= /:=/
				
				Colon       ::= /:/
				Arrow       ::= /\->/
				
				Comma       ::= /\,/
				
				LParen      ::= /\(/
				RParen      ::= /\)/
			\end{verbatim}
			
		\subsection{Parser Grammar}
		
			The following grammar specification uses a preceding \texttt{\%} for lexer tokens.
		
			\begin{verbatim}
				Program          ::=
				                 | €
				                 | GlobalStatement Program
				                 
				GlobalStatement  ::=
				                 | GVDeclaration
				                 | GFDeclaration
				                 
				GVDeclaration    ::=
				                 | %Global %Identifier %Assign GlobalExpression
				                 
				GFDeclaration    ::=
				                 | %Fn %Identifier                   %Arrow ReturnType Block
				                 | %Fn %Identifier %Colon FArguments %Arrow ReturnType Block
				                 
				FArguments       ::=
				                 | %Identifier %Colon Type
				                 | %Identifier %Colon Type %Comma FArguments
				
				ReturnType       ::=
				                 | %Void
				                 | Type
				                 
				Block            ::=
				                 | €
				                 | Statement Block
				
				Statement        ::=
				                 | VDeclaration
				                 | AssignStmt
				                 | IfStmt
				                 | WhileStmt
				                 | DoWhileStmt
				                 | ExprStmt
				                 | ReturnStmt
				                 
				VDeclaration     ::=
				                 | %Let %Identifier %Assign Expression
				                 
				AssignStmt       ::=
				                 | LHS %Assign Expression
				                 
				IfStmt           ::=
				                 | %If Expression Block ElifStmt
				                 
				ElifStmt         ::=
				                 | %Elif Expression Block ElifStmt
				                 | %Else Block
				                 | €
				                 
				WhileStmt        ::=
				                 | %While Expression Block
				
				DoWhileStmt      ::=
				                 | %Do Block %While Expression
				                 
				ExprStmt         ::=
				                 | Expression
				                 | Expression %Colon FArgs
				                 
				ReturnStmt       ::=
				                 | %Return
				                 | %Return Expression
				                 
				LHS              ::=
				                 | %Identifier
				                 
				Type             ::=
				                 | %Int
				                 | %Flt
				                 | %Char
				                 | %Bool
				                 
				GlobalExpression ::= Expression*
			
				Expression       ::=
				                 | ExprPrec30
				
				ExprPrec20       ::= 
				                 | ExprPrec30
				                 | ExprPrec30 %Equal     ExprPrec20
				                 | ExprPrec30 %NotEqual  ExprPrec20
				                 | ExprPrec30 %Greater   ExprPrec20
				                 | ExprPrec30 %Less      ExprPrec20
				                 | ExprPrec30 %GreaterEq ExprPrec20
				                 | ExprPrec30 %LessEq    ExprPrec20
				ExprPrec30       ::=
				                 | ExprPrec40
				                 | ExprPrec40 %Bitor ExprPrec30
				ExprPrec40       ::=
				                 | ExprPrec50
				                 | ExprPrec50 %Xor ExprPrec40
				ExprPrec50       ::=
				                 | ExprPrec60
				                 | ExprPrec60 %Bitand ExprPrec50
				ExprPrec60       ::=
				                 | ExprPrec70
				                 | ExprPrec70 %LShift ExprPrec60
				                 | ExprPrec70 %RShift ExprPrec60
				                 | ExprPrec70 %AShift ExprPrec60
				ExprPrec70       ::=
				                 | ExprPrec80
				                 | ExprPrec80 %Plus ExprPrec70
				                 | ExprPrec80 %Minus ExprPrec70
				ExprPrec80       ::=
				                 | ExprPrec90
				                 | ExprPrec90 %Star ExprPrec80
				ExprPrec90       ::=
				                 | ExprPrec100
				                 | ExprPrec100 %StarStar ExprPrec90
				ExprPrec100      ::=
				                 | SimpleExpression
				                 | %Dash ExprPrec100
				                 | %Bang ExprPrec100
				SimpleExpression ::=
				                 | %LParen Expression %RParen
				                 | %LiteralInt
				                 | %LiteralFlt
				                 | %LiteralChar
				                 | %LiteralBool
				                 | %Identifier
				                 | %Identifier Application
				                 
				Application      ::=
				                 | %LParen FArgs %RParen
				
				FArgs            ::=
				                 | €
				                 | NonEmptyFArgs
				NonEmptyFArgs    ::=
				                 | Expression
				                 | Expression %Comma NonEmptyFArgs
			\end{verbatim}
	
\end{document}






















