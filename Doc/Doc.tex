\documentclass{article}

\usepackage{listings, xcolor, enumitem, hyperref, multicol, booktabs, longtable, titlesec, amssymb, amsmath}

\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}

\usepackage[margin=2cm,a4paper]{geometry}

\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\lstdefinelanguage{Dromedar}{
	morekeywords = [1]{type,int,flt,char,bool,void,fn,string},
	morekeywords = [2]{true,false,null},
	morekeywords = [3]{return,if,else,while,do,for,denull,break,continue},
	morekeywords = [4]{let,mut,global},
	morekeywords = [5]{of,in},
	morekeywords = [6]{printf,sprintf,assert},
	morekeywords = [7]{module,native},
	comment = [l]{\#},
	%morecomment = [s]{/*}{*/},
	string = [b]',
	morestring = [b]"
}

\lstset{
	language=Dromedar,
	nolol=false,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	xleftmargin=\parindent,
	framexleftmargin=0.2em,
	belowskip=0.6em,
	%basewidth=0.5em,
	backgroundcolor=\color{white!90!black},
	emphstyle=\bfseries\slshape,
	basicstyle=\ttfamily\color{black},
	keywordstyle=\bfseries,
	commentstyle=\color{gray},
	stringstyle=\slshape,
	showstringspaces=false,
	tabsize=4
}

\renewcommand{\c}[1]{\texttt{#1}}
\newcommand{\code}[1]{\lstinline[columns=fixed]{#1}}

\newcommand{\drmrule}[5]{\frac{#1}{#2\vdash_{\mathsf{#3}}#4}\textsc{\ \small{#5}}}

\newcommand{\ruleapp}[1]{\vdash_{\mathsf{#1}}}
\newcommand{\mc}[1]{\textnormal{\code{#1}}}

\newcommand{\parw}{9cm}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\subsubsubsection}{\paragraph}

\begin{document}
	
	\vfill
	\begin{center}
		\large{Oliver Graf}\\
		\vspace{5cm}
		\large{\textsc{The}}\\\vspace{1cm}
		\Huge{\textsc{Dromedar}}\\\vspace{1cm}
		\large{\textsc{Programming Language}}
	\end{center}
	\vfill
	
	\clearpage
	
	\setcounter{tocdepth}{1}
	\tableofcontents
	\clearpage
	
	\section{Introduction}
	
		\subsection{Hello, World!}
		
			\begin{lstlisting}
fn main -> void
	print_str("Hello, World!")
			\end{lstlisting}
	
	\section{Typing System}
	
		Dromedar uses a static, strong and sound typing system -- typing errors cannot happen at runtime. It knows primitive and reference types.
		
		\subsection{Primitives}
		
			There are four primitive types:
			
			\begin{itemize}
				\item \code{int} represents 64-bit 2's complement (signed) integers.
				\item \code{flt} represents 64-bit IEEE-754 standard floating point numbers.
				\item \code{char} represents 8-bit UTF-8 characters.
				\item \code{bool} represents a 1-bit value: \code{true} and \code{false}.
			\end{itemize}
		
		\subsection{Reference Types}
		
			Reference types represent data structures that are laid over pointers to objects stored in the heap. References come in two types: Maybe-\code{null} and Definitely-not-\code{null} types. Operations like array subscript access are only possible with non-\code{null} types to ensure \code{null} safety.
			
			With a non-null-type \code{t}, the type \code{t?} represents a reference type that allows \code{null} values. Primitives are non-nullable.
			
			The following are reference types:
			
			\begin{itemize}
				\item \code{string} represents lists of characters.
				\item \code{[t]} represents an array with elements of type \code{t}.
			\end{itemize}
		
			Thus, e.g. \code{[[int]?]} represents a two-dimensional array of integers which is definitely non-\code{null}, whereas its rows may be \code{null}.
		
		\subsection{Mutability}
		
			In general, variables declared with the \code{let} keyword are immutable, whereas \code{mut} declarations create mutable variables.
			
			For references, Dromedar uses a different notion of mutability: Allowing the object to point to new objects is handled with the \code{mut} declaration. However, even immutable objects are allowed to call methods which alter their internal state -- for example changing an array's element.
			
		\subsection{Subtyping}
		
			Generally, variables and objects can be assigned values of \textit{subtypes}. Every type is a subtype of itself, and e.g. \code{t} is a subtype of \code{t?}. Generally, a subtype is a restricted value set of its supertype -- any subtype expression can be assigned to a variable of its supertype.
		
	\section{Expressions}
	
		Because Dromedar has a strong type system, it generally disallows any operations with operands of a non-specified type unless they are explicitly cast to the correct type before. This means that integer and floating point numbers cannot be added, multiplied, etc.
		
		The following table describes precedence and type of all operators:\\
		
		\begin{tabular}{l|l|c|l|l}
			\textbf{Operator} & \textbf{Name} & \textbf{Prec.} & \textbf{Assoc.} & \textbf{Types}\\
			\midrule
			\code{-} & Unary Negation & 100 & non-assoc. & \code{int -> int}\\
				&&&& \code{flt -> flt}\\
			\code{!} & Logical Negation &&& \code{bool -> bool}\\
			\midrule
			\code{**} & Exponentiation & 90 & right & \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
				&&&& \code{int,flt -> flt}\\
				&&&& \code{flt,int -> flt}\\
			\midrule
			\code{*} & Multiplication & 80 & left &
					 \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
				&&&& \code{int,flt -> flt}\\
				&&&& \code{flt,int -> flt}\\
			\midrule
			\code{+} & String Addition & 70 & left &
				\code{string,string -> string}\\
			\midrule
			\code{+},\code{-} & Addition & 70 & left &
					 \code{int,int -> int}\\
				& Subtraction &&&
					 \code{flt,flt -> flt}\\
				&&&& \code{int,flt -> flt}\\
				&&&& \code{flt,int -> flt}\\
				&&&& \code{char,int -> char}\\
				&&&& \code{int,char -> char}\\
			\midrule
			\code{<<},\code{>>},\code{>>>} & Left Shift & 60 & left & \code{int,int -> int}\\
			& Logical Right Shift &&& \\
			& Arithmetic Right Shift &&& \\
			\midrule
			\code{\&} & Bitwise And & 60 & left & \code{int,int -> int}\\
			\midrule
			\code{\^} & Bitwise Xor & 50 & left & \code{int,int -> int}\\
			\midrule
			\code{|} & Bitwise Or & 40 & left & \code{int,int -> int}\\
			\midrule
			\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=} & Comparison & 30 & non-assoc. & \code{[int/flt] -> bool} \\
				&&&& \code{[char] -> bool}\\
			\midrule
			\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=} & Structural Comparison & 30 & non-assoc. & \code{[string]->bool} \\
			\midrule
			\code{==},\code{!==} & Reference Comparison & 30 & non-assoc. & \code{[rt1...rtn]->bool}\\
			\midrule
			\code{\&\&} & Logical And & 20 & left & \code{bool,bool -> bool}\\
			\midrule
			\code{||} & Logical Or & 10 & left & \code{bool,bool -> bool}
		\end{tabular}\\
	
		Consider the following example:
		
		The expression \code{1+18-18+'a'} is well-typed (of type \code{char}) and gets parsed as \code{((1+18)-18)+'a'} and evaluated to \code{'b'}. \code{10 - 0.0} on the other hand is not well-typed as \code{-} cannot take an \code{int} and a \code{flt} operand as arguments.
		
		Comparison operators work differently to other (binary) operators: Instead of comparing just two expressions, Dromedar allows chaining expressions to create one final boolean value: For example, \code{1 < 2 != 5 >= 5} holds because every single sub-expression (\code{1 < 2}, \code{2 != 5} and \code{5 >= 5}) holds. Every expression is only evaluated once for its side-effect.
		
		Thus, \code{A op B op C} is not necessarily semantically equivalent to \code{A op B \&\& B op C}.
		
	\section{Handling Whitespace}
	
		In order to keep the code simple and easy to look at, Dromedar uses significant whitespace: Blocks of code (such as bodies of \code{if}) statements, are denoted by adding a level of indentation.
		
		Every line is either empty (this includes lines containing only comments), or it contains code. 
		
		If a line contains code, the level of its indentation is determined by its relationship to the previous line and its environment:
		
		Two neighboring lines of code within the same block of code must have exactly matching whitespace characters before their respective code starts. If a following line has a deeper level of indentation, it must match the whitespace characters of the previous line and then add a number of additional whitespace characters (space(s) and/or tab(s)).
		
		A line of code can only have a deeper indentation level of one step compared to the previous line. The first line of code is always a global instruction and as such has the lowest level of indentation. If it is indented, this level of indentation corresponds to a baseline indentation that every line of code must share.
		
		Consider this valid example:
		
		\begin{lstlisting}
  global x := 3 		# baseline indentation of two spaces
						# empty line -> indentation doesn't matter
  fn main : args:[string] -> int
  			Stdio.println("Hello, World!")	# deeper indentation level
  			return 0						# same indentation level
		\end{lstlisting}
		
		Blocks with the same level of indentation can have different indentation strings, but they must still match their environments, as follows:
		
		\begin{lstlisting}
		if <condition>
				BLOCK A
		else
		  BLOCK B
		\end{lstlisting}
		
		The two blocks have a different indentation level, but from context it is still clear that \code{BLOCK A} is a sub-block of the \code{if}-statement, whereas \code{BLOCK B} belongs to the \code{else}-statement.
		
	\section{Buildup of a Program}
	
		A program consists of a series of global statements -- global variable declarations and function definitions.
		
		\subsection{Global Declarations}
		
			Global variables are all assigned a value at the point of their declaration. This value is evaluated statically -- declaration expressions can only contain literals and global variables that were already declared previously.
			
			Functions are also declared globally. They can call each other and themselves recursively within their respective function bodies.
			
		\subsection{Standard Library}
		
			The Dromedar standard library includes the following functions and objects:
			
			\subsubsection{\code{Str}: String Operations}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{Str.of_int} & \code{int -> string} & transforms an integer into a string \\
					\code{Str.of_flt} & \code{flt -> string} & transforms a decimal number into a string
				\end{longtable}
			
			\subsubsection{\code{IO}: Standard I/O Operations}
			
				Printing operations are always preceded by the \code{IO} library name.
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{IO.print_str} & \code{string -> void} & prints a string to the console\\
					\code{IO.print_int} & \code{int -> void} & prints an integer to the console\\
					\code{IO.print_flt} & \code{flt -> void} & prints a real number to the console\\
					\code{IO.print_char} & \code{char -> void} & prints a character to the console\\
					\code{IO.print_bool} & \code{bool -> void} & prints \code{"true"} or \code{"false"} to the console
				\end{longtable}
			
			\subsubsection{\code{File}: File I/O}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{File.readall} & \code{string -> [string]} & returns all lines from the file with the given input name
				\end{longtable}
			
			\subsubsection{\code{Math} : Mathematical Operations}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{Math.sin} & \code{flt -> flt} & sine function \\
					\code{Math.cos} & \code{flt -> flt} & cosine function \\
					\code{Math.tan} & \code{flt -> flt} & tangent function \\
					\code{Math.e} & \code{flt} & Euler's constant \\
					\code{Math.pi} & \code{flt} & $\pi$ constant
				\end{longtable}
		
	\section{Garbage Collection}
	
		Dromedar uses an algorithm that combines the mark/sweep and reference counting approaches. It is a \textit{precise} garbage collection algorithm, meaning that it is capable of collecting all non-reachable objects and it will only attempt to GC exactly these (as opposed to conservative GC algorithms like the Boehm-Demers-Weiser garbage collector for C/C++).
		
		Internally, each reference object is stored in a central garbage collection table that counts the numbers of program references that can reach a program, as well as the set of its children.
		
		When a garbage collection run is triggered, the collector will free all objects that are not reachable. An object is deemed \textbf{reachable} if either its count of program references is nonzero, or if it is the child of a reachable object.
		
	\section{Formal Typing Rules}
	
		A typing rule takes the following shape: $$ \drmrule{\mathrm{Hypotheses}}{S,\dots}{type}{\mc{grammar spec}}{name} $$
		
		Here, $S$ represents a list of stacks (resp. a stack) of symbol definitions: $S \in (\mathsf{id} \times \mathsf{type} \times \{c,m\})^n$ for some block depth $n$ at any given point. In global context, $S$ has only one layer. $\mathsf{id}$ corresponds to the set of names that variables can have (related to the Lexer symbol \texttt{\%Identifier}), $\mathsf{type}$ to the set of types in a given program (related to the Parser symbol \texttt{Type}), and $\{c,m\}$ to the mutability of the object: $c$ represents an immutable value (as declared by \code{let}), and $m$ a mutable one (declared by \code{mut}).
		
		Writing $S$ in a proof rule enables access to functions and variables within the same module \code{M}, whereas $S_{\mc{N}}$ corresponds to the context from module \code{N}.
		
		The symbol $\in$ is defined as follows: $s\in S \Leftrightarrow \textnormal{$s$ is contained in \textit{any} layer of $S$}$, whereas $\in_0$ is true only if the symbol is at the top level of the symbol stack (i.e. defined in the same block). The operator $\cup$ on $S$ adds another binding to the top layer of the stack, whereas $\sqcup$ adds another layer to the stack.
		
		The following are the typing rules for Dromedar programs:
		
		\subsection{Subtyping Rules}
		
			\subsubsection{Cross-Typing}
			
				Cross types are types which aren't related by the subtype relation $\preceq$ but still allow for some typesafe interaction -- e.g. by assigning variables of one type to variables of another.
				
				The crosstype relation, denoted by the $\asymp$ operator, commutes.
				\begin{align*}
					\drmrule{}{}{T}{\mc{int} \asymp \mc{flt}}{CrossTyIntFlt},\ \ 
					\drmrule{}{}{T}{\mc{flt} \asymp \mc{int}}{CrossTyFltInt}
				\end{align*}
		
			\subsubsection{Trivial Rule}
			
				\begin{align*}
					\drmrule{}{}{T}{\mc{t} \preceq \mc{t}}{SubTyTrivial}
				\end{align*}
				
			\subsubsection{References}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{t1} \preceq \mc{t2}}{}{T}{\mc{t1} \preceq \mc{t2?}}{SubTyRefs},\ \ 
					\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{t2}}{}{T}{\mc{t1?} \preceq \mc{t2?}}{SubTyRefs}
				\end{align*}
				
			\subsubsection{Arrays}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{t2}}{}{T}{\mc{[t1]}\preceq\mc{[t2]}}{SubTyFuns}
				\end{align*}
		
			\subsubsection{Functions}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{u1}\preceq\mc{t1},\ \dots,\ \ruleapp{T}\mc{un}\preceq\mc{tn}\ \ \ruleapp{T}\mc{rt}\preceq\mc{ru}}{}{T}{\mc{(t1,...,tn)->rt} \preceq \mc{(u1,...,un)->ru}}{SubTyFuncs}
				\end{align*}
				
			\subsubsection{Subtypes and Supertypes}
			
				The functions $\mathsf{subtys}$ and $\mathsf{suptys}$ of $\mathsf{types}\to\mathcal{P}(\mathsf{types})$ compute the sub- and supertype set of the input type, respectively.
				
				They are used -- among others -- in the \textsc{ExpLitArr} rule.
				
				\begin{align*}
					\mathsf{subtys} &:=
						\left\{
							\begin{array}{lll}
								\mc{int} & \mapsto & \{\mc{int}\}\\
								\mc{flt} & \mapsto & \{\mc{flt}\}\\
								\mc{char} & \mapsto & \{\mc{char}\}\\
								\mc{bool} & \mapsto & \{\mc{bool}\}\\
								\mc{string} & \mapsto & \{\mc{string}\}\\
								\mc{t?} & \mapsto & \{\mc{u},\mc{u?} \;\mid\; \mc{u}\in\mathsf{subtys}(\mc{t})\}\\
								\mc{[t]} & \mapsto & \{\mc{[u]} \;\mid\; \mc{u}\in\mathsf{subtys}(\mc{t})\}\\
								\mc{(t1...tn)->rt} & \mapsto &
									\{\mc{(u1...un)->st} \;\mid\; \mc{u1...un}\in\mathsf{suptys}(\mc{t1...tn}),\mc{st}\in\mathsf{subtys}(\mc{rt})\}
							\end{array}
						\right.\\
					\mathsf{suptys} &:=
						\left\{
							\begin{array}{lll}
								\mc{int} & \mapsto & \{\mc{int}\}\\
								\mc{flt} & \mapsto & \{\mc{flt}\}\\
								\mc{char} & \mapsto & \{\mc{char}\}\\
								\mc{bool} & \mapsto & \{\mc{bool}\}\\
								\mc{string} & \mapsto & \{\mc{string},\mc{string?}\}\\
								\mc{t?} & \mapsto & \{\mc{u?} \;\mid\; \mc{u}\in\mathsf{suptys}(\mc{t})\}\\
								\mc{[t]} & \mapsto & \{\mc{[u]}, \mc{[u]?} \;\mid\; \mc{u}\in\mathsf{suptys}(\mc{t})\}\\
								\mc{(t1...tn)->rt} & \mapsto &
									\left[
									\begin{array}{l}
										\{\mc{(u1...un)->st},\mc{((u1...un)->st)?} \\\ \ \;\mid\; \mc{u1...un}\in\mathsf{subtys}(\mc{t1...tn}),\mc{st}\in\mathsf{suptys}(\mc{rt})\}
									\end{array}
									\right.
							\end{array}
						\right.
				\end{align*}
				
		\subsection{Declared Types}
			
				\begin{align*}
					\drmrule{}{T}{D}{\mc{int}}{TDInt},\ \ \drmrule{}{T}{D}{\mc{flt}}{TDFlt},\ \ 
					\drmrule{}{T}{D}{\mc{char}}{TDChar},\ \ \drmrule{}{T}{D}{\mc{bool}}{TDBool}\\
					\drmrule{T\ruleapp{D}\mc{t}}{T}{D}{\mc{[t]}}{TDArray},\ \ \drmrule{}{T}{D}{\mc{string}}{TDString},\ \ 
					\drmrule{\mc{id}\in T}{T}{D}{\mc{tid}}{TDNative}\\
					\drmrule{T\ruleapp{D}\mc{t1},\ \dots,\ T\ruleapp{D}\mc{tn}\ \ T\ruleapp{D}\mc{rt}}{T}{D}{\mc{(t1,...,tn)->rt}}{TDFunc}
				\end{align*}
		
		\subsection{Builtin Operators}
		
			Many builtin operators are overloaded, providing functionality for multiple input types.
			
			\subsubsection{Unary Operators}
			
				\subsubsubsection{Arithmetic Negation}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{-} :: \mc{int->int}}{TyUopNegInt},\ \ 
						\drmrule{}{}{O}{\mc{-} :: \mc{flt->flt}}{TyUopNegInt}
					\end{align*}
				
				\subsubsubsection{Logical Negation}

					\begin{align*}
						\drmrule{}{}{O}{\mc{!} :: \mc{bool->bool}}{TyUopNot}
					\end{align*}
			
			\subsubsection{Binary Operators}
			
				\subsubsubsection{Power}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{**} :: \mc{(int,int)->int}}{TyBopPowInt},\ \ &
						\drmrule{}{}{O}{\mc{**} :: \mc{(flt,flt)->flt}}{TyBopPowFlt}\\
						\drmrule{}{}{O}{\mc{**} :: \mc{(int,flt)->flt}}{TyBopPowIntFlt},\ \ &
						\drmrule{}{}{O}{\mc{**} :: \mc{(flt,int)->flt}}{TybopPowFltInt}
					\end{align*}
				
				\subsubsubsection{Multiplication, Division, Modulo}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{*} :: \mc{(int,int)->int}}{TyBopMulInt},\ \ &
						\drmrule{}{}{O}{\mc{*} :: \mc{(flt,flt)->flt}}{TyBopMulInt}\\
						\drmrule{}{}{O}{\mc{*} :: \mc{(int,flt)->flt}}{TyBopMulIntFlt},\ \ &
						\drmrule{}{}{O}{\mc{*} :: \mc{(flt,int)->flt}}{TybopMulFltInt}
					\end{align*}
					
					\begin{align*}
						\drmrule{}{}{O}{\mc{/} :: \mc{(int,int)->int}}{TyBopDivInt},\ \ &
						\drmrule{}{}{O}{\mc{/} :: \mc{(flt,flt)->flt}}{TyBopDivInt}\\
						\drmrule{}{}{O}{\mc{/} :: \mc{(int,flt)->flt}}{TyBopDivIntFlt},\ \ &
						\drmrule{}{}{O}{\mc{/} :: \mc{(flt,int)->flt}}{TybopDivFltInt}
					\end{align*}
					
					\begin{align*}
						\drmrule{}{}{O}{\mc{\%} :: \mc{(int,int)->int}}{TyBopModInt}
					\end{align*}
				
				\subsubsubsection{Addition and Subtraction}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,int)->int}}{TyBopAddInt},\ \ &
								\drmrule{}{}{O}{\mc{+} :: \mc{(flt,flt)->flt}}{TyBopAddFlt},\\
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,flt)->flt}}{TyBopAddIntFlt},\ \ & 
								\drmrule{}{}{O}{\mc{+} :: \mc{(flt,int)->flt}}{TyBopAddFltInt}\\
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,char)->char}}{TyBopAddCharR},\ \ &
								\drmrule{}{}{O}{\mc{+} :: \mc{(char,int)->char}}{TyBopAddCharL}
							\end{align*}\begin{align*}
								\drmrule{}{}{O}{\mc{+} :: \mc{(string,string)->string}}{TyBopAddString}
							\end{align*}\begin{align*}
								\drmrule{\mc{t}=\min_\preceq(\mathsf{suptys}(\mc{t1})\cap\mathsf{suptys}(\mc{t2}))}{}{O}{\mc{+} :: \mc{([t1],[t2])->[t]}}{TyBopAddArr}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,int)->int}}{TyBopSubInt},\ \ &
								\drmrule{}{}{O}{\mc{-} :: \mc{(flt,flt)->flt}}{TyBopSubFlt},\\
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,flt)->flt}}{TyBopSubIntFlt},\ \ & 
								\drmrule{}{}{O}{\mc{-} :: \mc{(flt,int)->flt}}{TBbopSubFltInt}\\
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,char)->char}}{TyBopSubCharR},\ \ &
								\drmrule{}{}{O}{\mc{-} :: \mc{(char,int)->char}}{TyBopSubCharL}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Shift Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{<<} :: \mc{(int,int)->int}}{TyBopLShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{>>} :: \mc{(int,int)->int}}{TyBopBitRShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{>>>} :: \mc{(int,int)->int}}{TyBopBitAShift}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Bitwise Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{\&} :: \mc{(int,int)->int}}{TyBopBitAnd}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{^} :: \mc{(int,int)->int}}{TyBopXor}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{|} :: \mc{(int,int)->int}}{TyBopBitOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Logical Operators}
				
					\begin{itemize}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{\&\&} :: \mc{(bool,bool)->bool}}{TyBopLogAnd}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{\^\^} :: \mc{(bool,bool)->bool}}{TyBopLogXor}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{||} :: \mc{(bool,bool)->bool}}{TyBopLogOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Comparison Operators}
				
					\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(int,...,int)->bool}}{TyCmpListInt}
					\end{align*}\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(flt,...,flt)->bool}}{TyCmpListFlt}
					\end{align*}\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(char,...,char)->bool}}{TyCmpListChar}
					\end{align*}\begin{align*}
						\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{string},\ \dots,\ \ruleapp{T}\mc{tn}\preceq\mc{string}}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(t1,...,tn)->bool}}{TyCmpListRefStr}
					\end{align*}\begin{align*}
						\drmrule{\ruleapp{T}\mc{t1}\preceq/\succeq\mc{t2},\ \dots,\ \ruleapp{T}\mc{t(n-1)}\preceq/\succeq\mc{tn}\ \ \mc{t1},\dots,\mc{tn}\textnormal{ reference types}}{}{O}{\{\mc{==},\mc{!==}\} :: \mc{(t1,...,tn)->bool}}{TyCmpListRefVal}
					\end{align*}
					
					
		\subsection{Expressions}
		
			\subsubsection{Subtyping Expression Rule}
			
				To reduce proof rule size, define the following rules:
				
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1}\ \ \ruleapp{T}\mc{t1}\preceq\mc{t}}{S}{ET}{\mc{exp} \trianglelefteq \mc{t}}{ExpSubLocal},\ \ &
					\drmrule{S\ruleapp{G}\mc{exp}::\mc{t1}\ \ \ruleapp{T}\mc{t1}\preceq\mc{t}}{S}{GT}{\mc{exp} \trianglelefteq \mc{t}}{ExpSubGlobal}\\
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1},\ \ \ruleapp{T}\mc{t1}\asymp\mc{t}}{S}{ET}{\mc{exp}\bowtie\mc{t}}{ExpCrossLocal}\ \ &
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1},\ \
					\ruleapp{T}\mc{t1}\asymp\mc{t}}{S}{GT}{\mc{exp}\bowtie\mc{t}}{ExpCrossGlobal}
				\end{align*}
		
			\subsubsection{Assignability}
			
				The rule $\ruleapp{A}$ defines when an expression can be assigned a value; $\ruleapp{AC}$ is equivalent to $\ruleapp{A}$ -- except that it also allows immutable objects whose children (e.g. array elements) can still be modified.
				
				\begin{align*}
					\drmrule{(\mc{id},\_,m)\in S}{S}{A}{\mc{id}}{ExpAssnId}\ \ 
					\drmrule{S\ruleapp{AC}\mc{e1}}{S}{A}{\mc{e1[e2]}}{ExpAssnSub}
				\end{align*}
				
				\begin{align*}
					\drmrule{(\mc{id},\_,\_)\in S}{S}{AC}{\mc{id}}{ExpAssnId'}\ \ 
					\drmrule{S\ruleapp{AC}\mc{e1}}{S}{AC}{\mc{e1[e2]}}{ExpAssnSub'}
				\end{align*}
				
			\subsubsection{Global Expressions}
			
				The rule $\vdash_G$ describes global expressions, which are restricted in a way that they can be computed at compile time. Global variables are also strictly non-\code{null}.
				
				The following copied rules use $\vdash_G$ instead of $\vdash_E$
				
				\subsubsubsection{Literals}
				
					\begin{itemize}
						\item \textsc{GExpLitInt} $:=$ \textsc{ExpLitInt}
						\item \textsc{GExpLitFlt} $:=$ \textsc{ExpLitFlt}
						\item \textsc{GExpLitChar} $:=$ \textsc{ExpLitChar}
						\item \textsc{GExpLitBool} $:=$ \textsc{ExpLitBool}
					\end{itemize}
				
				\subsubsubsection{Other Rules}
				
					\begin{itemize}
						\item \textsc{GExpId} $:=$ \textsc{ExpId}
						\item \textsc{GExpUop} $:=$ \textsc{ExpUop}
						\item \textsc{GExpBop} $:=$ \textsc{ExpBop}
						\item \textsc{GExpCmpList} $:=$ \textsc{ExpCmpList}
					\end{itemize}
				
					Note that global variable declarations cannot feature function calls or \code{null} declarations.
		
			\subsubsection{Literals}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{}{}{E}{n :: \mc{int}}{ExpLitInt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{f :: \mc{flt}}{ExpLitFlt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{c :: \mc{char}}{ExpLitChar}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{\mc{true} :: \mc{bool}}{ExpLitBoolTrue},\ \ 
							\drmrule{}{}{E}{\mc{false} :: \mc{bool}}{ExpLitBoolFalse}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{s :: \mc{string}}{ExpLitString}
						\end{align*}
					\item
						In arrays, the typechecker looks for the common subtypes of all array literal elements and looks for the one type \code{t} that is a supertype of all elements and which is a subtype of all other such subtypes (the minimum of the subtypes given the $\preceq$ relation on types).
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{e1}::\mc{t1},\ \dots,\ S\ruleapp{E}\mc{en}::\mc{tn}\ \ \mc{t} = \min_\preceq (\bigcap_{\mc{i}=\mc{1}}^{\mc{n}}\mathsf{suptys}(\mc{ti}))}{S}{E}{\mc{[e1,...,en]} :: \mc{[t]}}{ExpLitArr}
						\end{align*}
						
						Because the graph connecting types and subtypes is a forest of trees, if the intersection of supertypes is nonempty there is a unique solution \code{t}.
				\end{itemize}
			
			\subsubsection{Range List}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e1}::\mc{int}\ \ S\ruleapp{E}\mc{e2}::\mc{int}}{S}{E}{\mc{[e1 \%RangeSpecifier e2]} :: \mc{[int]}}{ExpRangeArr}
				\end{align*}
				
			\subsubsection{List Comprehension}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{l1}::\mc{[t1]},S_1:=S\cup\{(\mc{l1},\mc{t1},c)\}\ruleapp{E}\mc{l2}::\mc{[t2]},\ \dots,\ S_{n-1}\ruleapp{E}\mc{ln}::\mc{[tn]}\ \ S_n\ruleapp{E}(\mc{e},\mc{c})::(\mc{t},\mc{bool})}{S}{E}{\mc{[e : x1 in l1, ..., xn in ln : c]}::\mc{[t]}}{ExpLC}
				\end{align*}
			
			\subsubsection{Null}
			
				\begin{align*}
					\drmrule{\textnormal{\code{t} is a non-null ref. type}}{S}{E}{\mc{null of t} :: \mc{t?}}{ExpNull}
				\end{align*}
				
			\subsubsection{Dangerous Dereference}
			
				\begin{align*}
					\drmrule{S\ruleapp{E} \mc{exp} :: \mc{t?}}{S}{E}{\mc{assert exp} :: \mc{t}}{ExpDeref}
				\end{align*}
				
			\subsubsection{Ternary Operator}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c}::\mc{bool}\ \ S\ruleapp{E}\mc{e1}::\mc{t1},\ S\ruleapp{E}\mc{e2}::\mc{t2}\ \ \mc{t}=\min_\preceq(\mathsf{suptys}(\mc{t1})\cap\mathsf{suptys}(\mc{t2}))}{S}{E}{\mc{?c -> e1 : e2} :: \mc{t}}{ExpTern}
				\end{align*}
			
			\subsubsection{Identifiers}
			
				\begin{align*}
					\drmrule{(id,\mc{t},\_)\in S}{S}{E}{\mc{id} :: \mc{t}}{ExpId}
				\end{align*}
			
			\subsubsection{Unary Operations}
			
				Unary and Binary Operations do not need to do subtype checking, as they operate only on primitives.
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1}\ \ \ruleapp{O}\mc{op}::\mc{t1->t}}{S}{E}{\mc{op exp}::\mc{t}}{ExpUop}
				\end{align*}
			
			\subsubsection{Binary Operations}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e1}::\mc{t1}\ \ S\ruleapp{ET}\mc{e2}::\mc{t2}\ \ \ruleapp{O}\mc{op}::\mc{(t1,t2)->t}}{S}{E}{\mc{e1 op e2} :: \mc{t}}{ExpBop}
				\end{align*}
			
			\subsubsection{Function Calls}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{f}::\mc{(t1,...,tn)->rt}\ \ \mc{rt}\not\equiv\mc{void}\ \  S\ruleapp{ET}\mc{e1}\trianglelefteq\mc{t1}\vee\mc{e1}\bowtie\mc{t1},\ \dots,\ S\ruleapp{ET}\mc{en}\trianglelefteq\mc{tn}\vee\mc{en}\bowtie\mc{tn}}{S}{E}{\mc{f(e1,...,en)}::\mc{rt}}{ExpFunc}´
				\end{align*}
				
			\subsubsection{\code{sprintf} call}
			
				Because Dromedar is typesafe, a construct like \code{sprintf} is not possible within the standard framework of the language. Instead, it uses the \code{sprintf} keyword that generates a string from the input string and its arguments.
				
				First, define the rule to decide whether an object type is \textit{printable}:
				
				\begin{align*}
					\drmrule{}{}{P}{\mc{int}}{PrtInt},\ \ 
					\drmrule{}{}{P}{\mc{flt}}{PrtFlt},\ \ 
					\drmrule{}{}{P}{\mc{char}}{PrtChar},\ \ 
					\drmrule{}{}{P}{\mc{bool}}{PrtBool},\ \ 
					\drmrule{}{}{P}{\mc{string}}{PrtString}
				\end{align*}\begin{align*}
					\drmrule{\ruleapp{P}\mc{t}}{}{P}{\mc{[t]}}{PrtArr}
				\end{align*}
				
				\begin{align*}
					\drmrule{0\leq\mc{j1}<\mc{n},\ \dots,\ 0\leq\mc{jm}<\mc{n}\ \ S\ruleapp{E}\mc{e1}::\mc{t1},\ \dots,\ S\ruleapp{E}\mc{en}::\mc{tn}\ \ \ruleapp{P}\mc{t1},\ \dots,\ \ruleapp{P}\mc{tn}}{S}{E}{\mc{sprintf("...\{j1\}...\{jm\}...", e1,...,en)} :: \mc{string}}{ExpSprintf}
				\end{align*}
				
			\subsubsection{Subscript Access}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{s}::\mc{string}\ \ S\ruleapp{E}\mc{i}::\mc{int}}{S}{E}{\mc{s[i]} :: \mc{char}}{ExpArrSub}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{e}::\mc{[t]}\ \ S\ruleapp{E}\mc{i}::\mc{int}}{S}{E}{\mc{e[i]} :: \mc{t}}{ExpArrSub}
						\end{align*}
				\end{itemize}
			
			\subsubsection{Projection}
			
				\begin{align*}
					\drmrule{(\mc{f},\mc{t},\_)\in S_{\mc{Id}}}{S}{E}{\mc{Id.f}::\mc{t}}{ExpProjModule}
				\end{align*}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e}::\mc{[t]}}{S}{E}{\mc{e.length} :: \mc{int}}{ExpProjListLength}
				\end{align*}
			
			\subsubsection{Comparison Lists}
			
				\begin{align*}
					\drmrule{\ruleapp{O}\mc{op1}::\mc{(t0,t1)->t},\ \dots,\ \ruleapp{O}\mc{opn}::\mc{(t(n-1),tn)->t}\ \ S\ruleapp{ET} (\mc{e0},\dots,\mc{en}) [\trianglelefteq|\bowtie] (\mc{t0},\dots,\mc{tn})}{S}{E}{\mc{e0 op1 ... opn en} :: \mc{t}}{ExpCmpList}
				\end{align*}
				
		\subsection{Statements}
		
			In the statement typing rules, a statement rule produces a tuple $(S,r)$ where $S$ stands for the newly updated context, and $r\in\{\bot,\top\}$, where $\bot$ means that a statement might not return and $\top$ means that a statement definitely returns.
			
			To prevent potential mistakes, the typechecker prevents statements which are deemed unreachable at compile time. The logical operators $\vee$ and $\wedge$ operate as if $\bot\equiv0$ and $\top\equiv1$. A statement creates two such items, one for unreachability due to a \code{return}; one due to a \code{break}/\code{continue} statement. The difference is necessary due to different treatment after the loop body in a \code{do-while} statement.
			
			The $\top$ or $\bot$ on the LHS of a statement represents whether the current statement is in a block or not (this determines whether \code{break}/\code{continue} statements are applicable).
		
			\subsubsection{Local Variable Declarations}
			
				\begin{align*}
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{E}\mc{exp} :: \mc{t}}{S,T,\mc{rt},L}{S}{\mc{let id := exp} \Rightarrow (S \cup (\mc{id},\mc{t},c)),\bot}{StmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ T\ruleapp{D}\mc{t}\ \  S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{t}\vee\mc{exp}\bowtie\mc{t}}{S,T,\mc{rt},L}{S}{\mc{let id:t := exp} \Rightarrow (S \cup (\mc{id},\mc{t},c)),\bot}{StmtVTDeclConst}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{E}\mc{exp} :: \mc{t}}{S,T,\mc{rt},L}{S}{\mc{mut id := exp} \Rightarrow (S \cup (\mc{id},\mc{t},m)),\bot}{StmtVDeclMut}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ T\ruleapp{D}\mc{t}\ \  S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{t}\vee\mc{exp}\bowtie\mc{t}}{S,T,\mc{rt},L}{S}{\mc{mut id:t := exp} \Rightarrow (S \cup (\mc{id},\mc{t},m)),\bot}{StmtVTDeclMut}
				\end{align*}
			
			\subsubsection{Assignments}
			
				\begin{align*}
					\drmrule{S\ruleapp{A}\mc{lhs}\ \ S\ruleapp{E}\mc{lhs} :: \mc{t}\ \ S\ruleapp{ET}\mc{exp} \trianglelefteq \mc{t} \vee \mc{exp}\bowtie\mc{t}}{S,T,\mc{rt},L}{S}{\mc{lhs := exp} \Rightarrow S,\bot,\bot}{StmtAssn}
				\end{align*}
			
			\subsubsection{Expression Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp} :: \mc{t}}{S,\mc{rt}}{S}{\mc{exp} \Rightarrow S,\bot}{StmtExpr}\ \ \drmrule{S\ruleapp{E}\mc{(t1,...,tn)->void}}{S,T,\mc{rt},L}{S}{\mc{exp(a1,...,an)} \Rightarrow S,\bot,\bot}{StmtExprVoid}
				\end{align*}
				
			\subsubsection{\code{printf} Call}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{sprintf("...\{j1\}...\{jm\}...", e1,...,en)}::\mc{string}}{S,T,\mc{rt},L}{S}{\mc{printf("...\{j1\}...\{jm\}...", e1,...,en)} \Rightarrow S,\bot,\bot}{StmtPrintf}
				\end{align*}
				
			\subsubsection{\code{assert} Call}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{bool}}{S,T,\mc{rt},L}{S}{\mc{assert exp}\Rightarrow S,\bot}{StmtAssert}
				\end{align*}
			
			\subsubsection{If Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,T,\mc{rt},L\ruleapp{S}\mc{b1}\Rightarrow S_1,R_1,B_1\ \ S,T,\mc{rt},L\ruleapp{S}\mc{b2}\Rightarrow S_2,R_2,B_2}{S,T,\mc{rt},L}{S}{\mc{if c b1 else b2} \Rightarrow S,R_1\wedge R_2,B_1\wedge B_2}{StmtIf}
				\end{align*}
				
			\subsubsection{Checked Null Casts}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t?}\ \ S\cup\{(\mc{r},\mc{t},c)\},T,\mc{rt},L \ruleapp{S} \mc{b1} \Rightarrow S',R_1,B_2\ \ S,T,\mc{rt},L \ruleapp{S}\mc{b2}\Rightarrow S'',R_2,B_2}{S,T,\mc{rt},L}{S}{\mc{denull r := exp b1 else b2} \Rightarrow S,R_1\wedge R_2,B_1\wedge B_2}{StmtNullCast}
				\end{align*}
			
			\subsubsection{While Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,T,\mc{rt},\top\ruleapp{S}\mc{b}\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{while c b} \Rightarrow S,\bot,\bot}{StmtWhile}
				\end{align*}
			
			\subsubsection{Do-While Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,T,\mc{rt},\top\ruleapp{S}\mc{b}\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{do b while c} \Rightarrow S,R,\bot}{StmtDoWhile}
				\end{align*}
				
			\subsubsection{For Statements}
	
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{estart}::\mc{int}\ \ S\ruleapp{E}\mc{eend}::\mc{int}\ \ S\cup \{ (\mc{id},\mc{int},c) \},T,\mc{rt},\top\ruleapp{S} \mc{b}\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{for id := estart \%RangeSpecifier eend b} \Rightarrow S,\bot,\bot}{StmtFor}
				\end{align*}\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{[t]}\ \ S\cup\{(\mc{id},\mc{t},c)\},T,\mc{rt},\top\ruleapp{S}b\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{for id in exp b} \Rightarrow S,\bot,\bot}{StmtForIn}
				\end{align*}
				
			\subsubsection{Break and Continue}
			
				\begin{align*}
					\drmrule{}{S,T,\mc{rt},\top}{S}{\mc{break} \Rightarrow S,\bot,\top}{StmtBreak},\ \ 
					\drmrule{}{S,T,\mc{rt},\top}{S}{\mc{continue} \Rightarrow S,\bot,\top}{StmtContinue}
				\end{align*}
			
			\subsubsection{Return Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{rt}\vee\mc{exp}\bowtie\mc{rt}}{S,\mc{rt}}{S}{\mc{return exp} \Rightarrow S,\top}{StmtReturnExp},\ \  \drmrule{}{S,T,\mc{void},L}{S}{\mc{return}\Rightarrow S,\top,\bot}{StmtReturn}
				\end{align*}
				
			\subsubsection{Blocks}
			
				\begin{align*}
					\drmrule{S\sqcup\{\},\mc{rt},L\ruleapp{S}\mc{s1} \Rightarrow S_1,\bot,\bot\ \ S_1,T,\mc{rt},L\ruleapp{S}\mc{s2} \Rightarrow S_2,\bot,\bot,\ \dots,\ S_{n-1},\mc{rt},L\ruleapp{S}\mc{sn} \Rightarrow S_n,R,B}{S,\mc{rt},L}{S}{\mc{s1 ... sn} \Rightarrow S_n,R,B}{StmtBlock}
				\end{align*}
		
		\subsection{Global Statements}
		
			\subsubsection{Global Function Declaration}
			
				\begin{align*}
					\drmrule{T\ruleapp{D}\mc{t1},\dots,T\ruleapp{D}\mc{tn},T\ruleapp{D}\mc{rt}\ \ S\sqcup\{(\mc{a1},\mc{t1},c),\dots,(\mc{an},\mc{tn},c)\},T,\mc{rt},\bot\ruleapp{S} \mc{b} \Rightarrow S',\top,\bot\;(\textnormal{or \code{rt=void}}) \ \ \mc{a1},\dots,\mc{an} \textnormal{ distinct}}{S,T}{G}{\mc{fn id : a1:t1, ..., an:tn -> rt b} \Rightarrow S,T}{GStmtFDecl}
				\end{align*}
			
			\subsubsection{Global Variable Declaration}
			
				\begin{align*}
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{G}\mc{exp} :: \mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global id := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\},T}{GStmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ T\ruleapp{D}\mc{t}\ \ S\ruleapp{GT}\mc{exp}\trianglelefteq\mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global id:t := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\},T}{GStmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{G}\mc{exp} :: \mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global mut id := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},m)\},T}{GStmtVDeclMut}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ T\ruleapp{D}\mc{t}\ \ S\ruleapp{GT}\mc{exp}\trianglelefteq\mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global mut id:t := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},m)\},T}{GStmtVDeclMut}
				\end{align*}
				
			\subsubsection{Native Declarations}
			
				\begin{align*}
					\drmrule{\mc{t}\not\in T}{S,T}{G}{\mc{native type t} \Rightarrow S,T\cup\{\mc{t}\}}{GStmtNativeTDecl}\\
					\drmrule{}{S,T}{G}{\mc{native fn f: t1,...,tn -> rt} \Rightarrow S,T}{GStmtNativeFDecl}\\
					\drmrule{(\mc{id},\_,\_)\not\in S}{S,T}{G}{\mc{native t id} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\},T}{GStmtNativeVDecl}
				\end{align*}
				
			\subsubsection{Module Header}
			
				\begin{align*}
					\drmrule{}{S,T}{G}{\mc{module M} \Rightarrow S \textnormal{ where $S_{\mc{M}} = S$ with \code{M} as the only active module},T}{GStmtModule}
				\end{align*}
			
			\subsubsection{Program}
			
				\begin{align*}
					\drmrule{S_0,T_0 \ruleapp{G} \mc{gs1} \Rightarrow S_1,T_1\ \dots,\ S_{n-1},T_{n-1} \ruleapp{G} \mc{gsn} \Rightarrow S_n,T_n}{S_0,T_0}{G}{\mc{gs1 ... gsn} \Rightarrow S_n,T_n}{GStmtProgram}
				\end{align*}
				
		\subsection{Context Buildup}
		
			\subsubsection{Global Function Declarations}
			
				\begin{align*}
					\drmrule{(\mc{id},\_) \not\in S}{S,T}{GCF}{\mc{fn id : a1:t1, ..., an:tn -> rt b} \Rightarrow S \cup \{(\mc{id}, \mc{(t1,...,tn)->rt}, c)\},T}{GStmtFCtxtFDecl}\\
					\drmrule{(\mc{id},\_) \not\in S}{S,T}{GCF}{\mc{native fn f : t1,...,tn -> rt} \Rightarrow S \cup \{(\mc{id}, \mc{(t1,...,tn)->rt}, c)\},T}{GStmtFCtxtNFDecl}
				\end{align*}\begin{align*}
					\drmrule{}{S,T}{GCF}{\mc{global X := Y} \Rightarrow S,T}{GStmtFCtxtVDecl}\\
					\drmrule{}{S,T}{GCF}{\mc{native type T} \Rightarrow S,T}{GStmtFCtxtNTDecl}\\
					\drmrule{}{S,T}{GCF}{\mc{native t id} \Rightarrow S,T}{GStmtFCtxtNVDecl}
				\end{align*}\begin{align*}
					\drmrule{}{S,T}{GCF}{\mc{module M} \Rightarrow S\textnormal{ where $S_{\mc{M}} = S$ with \code{M} as the only active module}, T}{GStmtFCtxtModule}
				\end{align*}
			
			\subsubsection{Program: Functions}
			
				\begin{align*}
					\drmrule{S_0,T_0 \ruleapp{GCF} \mc{gs1} \Rightarrow S_1,T_1,\ \dots,\ S_{n-1},T_{n-1} \ruleapp{GCF} \mc{gsn} \Rightarrow S_n,T_n}{S_0,T_0}{GC}{\mc{gs1 ... gsn} \Rightarrow S_n,T_n \textnormal{ with no active module}}{GStmtCtxtFuncs}
				\end{align*}
			
		\subsection{Rule for Program Typechecking}
		
			Let $S^\star$ be the starting context which contains the builtin context. It looks as follows:
			
			\begin{align*}
				S^\star := \{\}\sqcup \left\{
					\begin{array}{lll}
						(\mc{string\_of\_int},&\mc{int -> string},&c),\\ (\mc{string\_of\_flt},&\mc{flt -> string},&c),\\
						(\mc{string\_concat},&\mc{(string,string) -> string},&c),\\
						(\mc{io\_print},&\mc{string -> void},&c)
					\end{array}
				\right\}
			\end{align*}
			
			Let $\mathsf{maintys}$ be the legal set of types of main functions -- one of which must be contained in a program.
			
			\begin{align*}
				\mathsf{maintys} := \left\{
					\begin{array}{ll}
						\mc{void -> void}, & \mc{void -> int},\\
						\mc{[string] -> void}, & \mc{[string] -> int}
					\end{array}
				\right\}
			\end{align*}
		
			Then, the program rule \textsc{Prog} shall be:
		
			\begin{align*}
				\drmrule{S^\star,\emptyset \ruleapp{GC} \mc{prog} \Rightarrow S',T_0 \ \ \exists!\; \mc{ft}\in\mathsf{maintys}:\;(\mc{main},\mc{ft},c)\in S'\ \ S',T_0 \ruleapp{G} \mc{prog} \Rightarrow S,T_1}{}{}{\mc{prog}}{Prog}
			\end{align*}
		
	\section{Formal Grammar}
	
		\subsection{Lexer Grammar}
		
			The Lexer Grammar is specified using \textbf{regular expressions}:
			
			\begin{verbatim}
				LiteralInt   ::= /[1-9]\d*/
				LiteralFlt   ::= /\d+\.\d+/
				LiteralChar  ::= /'([^'\\]|(\\[\\nrt']))'/
				LiteralBool  ::= /true|false/
				LiteralStr   ::= /"([^"\\]|(\\[\\nrt"]))*"/
				
				Identifier   ::= /[a-zA-Z][a-zA-Z0-9_]*/
				
				module       ::= /module/
				native       ::= /native/
				
				global       ::= /global/
				fn           ::= /fn/
				let          ::= /let/
				mut          ::= /mut/
				
				type         ::= /type/
				int          ::= /int/
				flt          ::= /flt/
				char         ::= /char/
				bool         ::= /bool/
				string       ::= /string/
				void         ::= /void/
				
				null         ::= /null/
				denull       ::= /denull/
				
				of           ::= /of/
				in           ::= /in/
				
				if           ::= /if/
				elif         ::= /elif/
				else         ::= /else/
				do           ::= /do/
				while        ::= /while/
				for          ::= /for/
				
				break        ::= /break/
				continue     ::= /continue/
				
				printf       ::= /printf/
				sprintf      ::= /sprintf/
				assert       ::= /assert/
				 
				return       ::= /return/
				
				Dash         ::= /\-/
				Bang         ::= /!/
				Star         ::= /\*/
				Plus         ::= /\+/
				LShift       ::= /<</
				RShift       ::= />>/
				AShift       ::= />>>/
				Bitand       ::= /&/
				Xor          ::= /\^/
				Bitor        ::= /\|/
				Logand       ::= /&&/
				Logor        ::= /\|\|/
				
				Equal        ::= /=/
				NotEqual     ::= /!=/
				Greater      ::= />/
				Less         ::= /</
				GreaterEq    ::= />=/
				LessEq       ::= /<=/
				
				RefEqual     ::= /==/
				RefNotEqual  ::= /!==/
				
				Assign       ::= /:=/
				
				Colon        ::= /:/
				Arrow        ::= /\->/
				
				Dot          ::= /\./
				Comma        ::= /\,/
				
				Dots         ::= /\.\.\./
				DotsPipe     ::= /\.\.\|/
				PipeDots     ::= /\|\.\./
				PipeDotPipe  ::= /\|\.\|/
				
				LParen       ::= /\(/
				RParen       ::= /\)/
				LBrack       ::= /\[/
				RBrack       ::= /\]/
				
				QuestionMark ::= /\?/
			\end{verbatim}
			
		\subsection{Parser Grammar}
		
			The following grammar specification uses a preceding \texttt{\%} for lexer tokens.
		
			\begin{verbatim}
				Program          ::=
				                 | €
				                 | GlobalStatement Program
				                 
				GlobalStatement  ::=
				                 | GVDeclaration
				                 | GFDeclaration
				                 | %Module %Identifier
				                 | %Native NatDecl
				                 
				GVDeclaration    ::=
				                 | %Global      %Identifier             %Assign GlobalExpression
				                 | %Global      %Identifier %Colon Type %Assign GlobalExpression
				                 | %Global %Mut %Identifier             %Assign GlobalExpression
				                 | %Global %Mut %Identifier %Colon Type %Assign GlobalExpression
				                 
				GFDeclaration    ::=
				                 | %Fn %Identifier                   %Arrow ReturnType Block
				                 | %Fn %Identifier %Colon FArguments %Arrow ReturnType Block
				                 
				NatDecl          ::=
				                 | %Type %Identifier
				                 | %Fn %Identifier NamelessArgtyList %Arrow ReturnType
				                 | Type %Identifier
				                 
				FArguments       ::=
				                 | %Identifier %Colon Type
				                 | %Identifier %Colon Type %Comma FArguments
				
				ReturnType       ::=
				                 | %Void
				                 | Type
				                 
				Block            ::=
				                 | €
				                 | Statement Block
				
				Statement        ::=
				                 | VDeclaration
				                 | AssignStmt
				                 | IfStmt
				                 | NullCastStmt
				                 | WhileStmt
				                 | DoWhileStmt
				                 | ForStmt
				                 | ExprStmt
				                 | ReturnStmt
				                 | %Break
				                 | %Continue
				                 
				VDeclaration     ::=
				                 | %Let %Identifier             %Assign Expression
				                 | %Let %Identifier %Colon Type %Assign Expression
				                 | %Mut %Identifier             %Assign Expression
				                 | %Mut %Identifier %Colon Type %Assign Expression
				                 
				AssignStmt       ::=
				                 | LHS %Assign Expression
				                 
				IfStmt           ::=
				                 | %If Expression Block ElifStmt
				                 
				ElifStmt         ::=
				                 | %Elif Expression Block ElifStmt
				                 | %Else Block
				                 | €
				                 
				NullCastStmt     ::=
				                 | %Denull %Id %Assign Expression Block
				                 | %Denull %Id %Assign Expression Block %Else Block
				                 
				WhileStmt        ::=
				                 | %While Expression Block
				
				DoWhileStmt      ::=
				                 | %Do Block %While Expression
				                 
				ForStmt          ::=
				                 | %For %Id %Assign Expr RangeSpecifier Expr Block
				                 | %For %Id %In Expr Block
				                 
				RangeSpecifier   ::=
				                 | %Dots
				                 | %DotsPipe
				                 | %PipeDots
				                 | %PipeDotPipe
				                 
				ExprStmt         ::=
				                 | Expression
				                 | %Printf %LParen %LiteralStr PrintfArglist %RParen
				                 | %Assert Expression
				                 
				ReturnStmt       ::=
				                 | %Return
				                 | %Return Expression
				                 
				LHS              ::=
				                 | %Identifier
				                 
				Type             ::=
				                 | %Int
				                 | %Flt
				                 | %Char
				                 | %Bool
				                 | RefType
				                 | RefType %QuestionMark
				                 
				RefType          ::=
				                 | %String
				                 | %LBrack Type %RBrack
				                 | %Identifier
				                 | %Identifier %Dot %Identifier
				                 
				GlobalExpression ::= Expression*
			
				Expression       ::=
				                 | %Null %Of RefType
				                 | %LBrack %RBrack %Of Type
				                 | %QuestionMark Expression %Arrow Expression %Colon Expression
 				                 | %Assert Expression
				                 | ExprPrec30
				
				ExprPrec20       ::= 
				                 | ExprPrec30
				                 | ExprPrec30 %Equal       ExprPrec20
				                 | ExprPrec30 %NotEqual    ExprPrec20
				                 | ExprPrec30 %Greater     ExprPrec20
				                 | ExprPrec30 %Less        ExprPrec20
				                 | ExprPrec30 %GreaterEq   ExprPrec20
				                 | ExprPrec30 %LessEq      ExprPrec20
				                 | ExprPrec30 %RefEqual    ExprPrec20
				                 | ExprPrec30 %RefNotEqual ExprPrec20
				ExprPrec30       ::=
				                 | ExprPrec40
				                 | ExprPrec40 %Bitor ExprPrec30
				ExprPrec40       ::=
				                 | ExprPrec50
				                 | ExprPrec50 %Xor ExprPrec40
				ExprPrec50       ::=
				                 | ExprPrec60
				                 | ExprPrec60 %Bitand ExprPrec50
				ExprPrec60       ::=
				                 | ExprPrec70
				                 | ExprPrec70 %LShift ExprPrec60
				                 | ExprPrec70 %RShift ExprPrec60
				                 | ExprPrec70 %AShift ExprPrec60
				ExprPrec70       ::=
				                 | ExprPrec80
				                 | ExprPrec80 %Plus ExprPrec70
				                 | ExprPrec80 %Minus ExprPrec70
				ExprPrec80       ::=
				                 | ExprPrec90
				                 | ExprPrec90 %Star ExprPrec80
				ExprPrec90       ::=
				                 | ExprPrec100
				                 | ExprPrec100 %StarStar ExprPrec90
				ExprPrec100      ::=
				                 | SimpleExpression
				                 | %Dash ExprPrec100
				                 | %Bang ExprPrec100
				                 
				SimpleExpression ::=
				                 | BaseExpression Application
				                 | BaseExpression
				
				BaseExpression   ::=
				                 | %LParen Expression %RParen
				                 | %LBrack CommaExpList %RBrack
				                 | %LBrack Expression RangeSpecifier Expression %RBrack
				                 | %LBrack Expression %Colon ListCmpVars %RBrack
				                 | %LBrack Expression %Colon ListCmpVars %Colon Expression %RBrack
				                 | %LiteralInt
				                 | %LiteralFlt
				                 | %LiteralChar
				                 | %LiteralBool
				                 | %LiteralStr
				                 | %Identifier
				                 | %Sprintf %LParen %LiteralStr PrintfArglist %RParen
				                 
				PrintfArgList    ::=
				                 | €
				                 | %Comma Expression PrintfArgList
				                 
				ListCmpVars      ::=
				                 | €
				                 | ListCmpVarsNE
				                 
				ListCmpVarsNE    ::=
				                 | %Identifier %In Expression
				                 | %Identifier %In Expression %Comma ListCmpVarsNE
				                 
				Application      ::=
				                 | %LParen CommaExpList %RParen
				                 | %LParen CommaExpList %RParen Application
				                 | %LBrack Expression %RBrack
				                 | %LBrack Expression %RBrack Application
				                 | %Dot Identifier
				                 | %Dot Identifier Application
				
				CommaExpList     ::=
				                 | €
				                 | CommaExpListNE
				CommaExpListNE   ::=
				                 | Expression
				                 | Expression %Comma CommaExpListNE
			\end{verbatim}
	
\end{document}






















