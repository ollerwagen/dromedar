\documentclass{article}

\usepackage{listings, xcolor, enumitem, hyperref, multicol, booktabs, longtable, titlesec, amssymb, amsmath}

\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}

\usepackage[margin=2cm,a4paper]{geometry}

\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\lstdefinelanguage{Dromedar}{
	morekeywords = [1]{int,flt,char,bool,void,fn,string},
	morekeywords = [2]{true,false,null},
	morekeywords = [3]{return,if,else,while,do,for},
	morekeywords = [4]{let,mut,global},
	morekeywords = [5]{of},
	comment = [l]{\#},
	%morecomment = [s]{/*}{*/},
	string = [b]',
	morestring = [b]"
}

\lstset{
	language=Dromedar,
	nolol=false,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	xleftmargin=\parindent,
	framexleftmargin=0.2em,
	belowskip=0.6em,
	%basewidth=0.5em,
	backgroundcolor=\color{white!90!black},
	emphstyle=\bfseries\slshape,
	basicstyle=\ttfamily\color{black},
	keywordstyle=\bfseries,
	commentstyle=\color{gray},
	stringstyle=\slshape,
	showstringspaces=false,
	tabsize=4
}

\renewcommand{\c}[1]{\texttt{#1}}
\newcommand{\code}[1]{\lstinline[columns=fixed]{#1}}

\newcommand{\drmrule}[5]{\frac{#1}{#2\vdash_{\mathsf{#3}}#4}\textsc{\ \small{#5}}}

\newcommand{\ruleapp}[1]{\vdash_{\mathsf{#1}}}
\newcommand{\mc}[1]{\textnormal{\code{#1}}}

\newcommand{\parw}{9cm}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\subsubsubsection}{\paragraph}

\begin{document}
	
	\vfill
	\begin{center}
		\large{Oliver Graf}\\
		\vspace{5cm}
		\large{\textsc{The}}\\\vspace{1cm}
		\Huge{\textsc{Dromedar}}\\\vspace{1cm}
		\large{\textsc{Programming Language}}
	\end{center}
	\vfill
	
	\clearpage
	
	\setcounter{tocdepth}{1}
	\tableofcontents
	\clearpage
	
	\section{Introduction}
	
	\section{Typing System}
	
		Dromedar uses a static, strong and sound typing system -- typing errors cannot happen at runtime. It knows primitive and reference types.
		
		\subsection{Primitives}
		
			There are four primitive types:
			
			\begin{itemize}
				\item \code{int} represents 64-bit 2's complement (signed) integers.
				\item \code{flt} represents 64-bit IEEE-754 standard floating point numbers.
				\item \code{char} represents 8-bit UTF-8 characters.
				\item \code{bool} represents a 1-bit value: \code{true} and \code{false}.
			\end{itemize}
		
		\subsection{Reference Types}
		
			Reference types represent data structures that are laid over pointers to objects stored in the heap. References come in two types: Maybe-\code{null} and Definitely-not-\code{null} types. Operations like array subscript access are only possible with non-\code{null} types to ensure \code{null} safety.
			
			With a non-null-type \code{t}, the type \code{t?} represents a reference type that allows \code{null} values. Primitives are non-nullable, as are \code{string}s.
			
			The following are reference types:
			
			\begin{itemize}
				\item \code{string} represents lists of characters.
				\item \code{[t]} represents a list of type \code{t}.
			\end{itemize}
		
			Thus, e.g. \code{[[int]?]} represents a two-dimensional array of integers which is definitely non-\code{null}, whereas its rows may be \code{null}.
		
		\subsection{Mutability}
		
			In general, variables declared with the \code{let} keyword are immutable, whereas \code{mut} declarations allow mutable variables.
			
			For references, there are different notions of mutability: Allowing the object to point to new objects is handled with the \code{mut} declaration. However, even immutable objects are allowed to call methods which alter their internal state -- for example changing an array's element.
			
		\subsection{Subtyping}
		
			Generally, variables and objects can be assigned values of \textit{subtypes}. Every type is a subtype of itself, and e.g. \code{t} is a subtype of \code{t?}. Generally, a subtype is a restricted value set of its supertype -- any subtype expression can be assigned to a variable of its supertype.
		
	\section{Expressions}
	
		Because Dromedar has a strong type system, it generally disallows any operations with operands of a non-specified type unless they are explicitly cast to the correct type before. This means that integer and floating point numbers cannot be added, multiplied, etc.
		
		The following table describes precedence and type of all operators:\\
		
		\begin{tabular}{l|l|c|l|l}
			\textbf{Operator} & \textbf{Name} & \textbf{Prec.} & \textbf{Assoc.} & \textbf{Types}\\
			\midrule
			\code{-} & Unary Negation & 100 & non-assoc. & \code{int -> int}\\
				&&&& \code{flt -> flt}\\
			\code{!} & Logical Negation &&& \code{bool -> bool}\\
			\midrule
			\code{**} & Exponentiation & 90 & right & \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
			\midrule
			\code{*} & Multiplication & 80 & left & \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
			\midrule
			\code{+},\code{-} & Addition & 70 & left & \code{int,int -> int}\\
				& Subtraction &&& \code{flt,flt -> flt}\\
				&&&& \code{char,int -> char}\\
				&&&& \code{int,char -> char}\\
			\midrule
			\code{<<},\code{>>},\code{>>>} & Left Shift & 60 & left & \code{int,int -> int}\\
			& Logical Right Shift &&& \\
			& Arithmetic Right Shift &&& \\
			\midrule
			\code{\&} & Bitwise And & 60 & left & \code{int,int -> int}\\
			\midrule
			\code{\^} & Bitwise Xor & 50 & left & \code{int,int -> int}\\
			\midrule
			\code{|} & Bitwise Or & 40 & left & \code{int,int -> int}\\
			\midrule
			\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=} & Comparison & 30 & non-assoc. & \code{[int] -> bool} \\
				&&&& \code{[flt] -> bool}\\
			\midrule
			\code{\&\&} & Logical And & 20 & left & \code{bool,bool -> bool}\\
			\midrule
			\code{||} & Logical Or & 10 & left & \code{bool,bool -> bool}
		\end{tabular}\\
	
		Consider the following example:
		
		The expression \code{1+18-18+'a'} is well-typed (of type \code{char}) and gets parsed as \code{((1+18)-18)+'a'} and evaluated to \code{'b'}. \code{10 - 0.0} on the other hand is not well-typed as \code{-} cannot take an \code{int} and a \code{flt} operand as arguments.
		
		Comparison operators work differently to other (binary) operators: Instead of comparing just two expressions, Dromedar allows chaining expressions to create one final boolean value: For example, \code{1 < 2 != 5 >= 5} holds because every single sub-expression (\code{1 < 2}, \code{2 != 5} and \code{5 >= 5}) holds. Every expression is only evaluated once for its side-effect.
		
		Thus, \code{A op B op C} is not necessarily semantically equivalent to \code{A op B \&\& B op C}.
		
	\section{Handling Whitespace}
	
		In order to keep the code simple and easy to look at, Dromedar uses significant whitespace: Blocks of code (such as bodies of \code{if}) statements, are denoted by adding a level of indentation.
		
		Every line is either empty (this includes lines containing only comments), or it contains code. 
		
		If a line contains code, the level of its indentation is determined by its relationship to the previous line and its environment:
		
		Two neighboring lines of code within the same block of code must have exactly matching whitespace characters before their respective code starts. If a following line has a deeper level of indentation, it must match the whitespace characters of the previous line and then add a number of additional whitespace characters (space(s) and/or tab(s)).
		
		A line of code can only have a deeper indentation level of one step compared to the previous line. The first line of code is always a global instruction and as such has the lowest level of indentation. If it is indented, this level of indentation corresponds to a baseline indentation that every line of code must share.
		
		Consider this valid example:
		
		\begin{lstlisting}
  global x := 3 		# baseline indentation of two spaces
						# empty line -> indentation doesn't matter
  fn main : args:[string] -> int
  			Stdio.println("Hello, World!")	# deeper indentation level
  			return 0						# same indentation level
		\end{lstlisting}
		
		Blocks with the same level of indentation can have different indentation strings, but they must still match their environments, as follows:
		
		\begin{lstlisting}
		if <condition>
				BLOCK A
		else
		  BLOCK B
		\end{lstlisting}
		
		The two blocks have a different indentation level, but from context it is still clear that \code{BLOCK A} is a sub-block of the \code{if}-statement, whereas \code{BLOCK B} belongs to the \code{else}-statement.
		
	\section{Buildup of a Program}
	
		A program consists of a series of global statements -- global variable declarations and function definitions.
		
		\subsection{Global Declarations}
		
			Global variables are all assigned a value at the point of their declaration. This value is evaluated statically -- declaration expressions can only contain literals and global variables that were already declared previously.
			
			Functions are also declared globally. They can call each other and themselves recursively within their respective function bodies.
			
		\subsection{Builtin Functions}
		
			The Dromedar standard library includes the following functions:
			
			\subsubsection{String Operations}
			
				String operations are always preceded by the \code{Str} library name.
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{Str.of_int} & \code{int -> string} & transforms an integer into a string \\
					\code{Str.of_flt} & \code{flt -> string} & transforms a decimal number into a string \\
					\code{Str.concat} & \code{(string,string) -> string} & concatenates two strings
				\end{longtable}
			
			\subsubsection{I/O}
			
				Printing operations are always preceded by the \code{IO} library name.
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{IO.print_str} & \code{string -> void} & prints a string to the console\\
					\code{IO.print_int} & \code{int -> void} & prints an integer to the console\\
					\code{IO.print_flt} & \code{flt -> void} & prints a real number to the console
				\end{longtable}
		
	\section{Formal Typing Rules}
	
		A typing rule takes the following shape: $$ \drmrule{\mathrm{Hypotheses}}{S,\dots}{type}{\mc{grammar spec}}{name} $$
		
		Here, $S$ represents a stack of symbol definitions: $S \in (\mathsf{id} \times \mathsf{type} \times \{c,m\})^n$ for some block depth $n$ at any given point. In global context, $S$ has only one layer. $\mathsf{id}$ corresponds to the set of names that variables can have (related to the Lexer symbol \texttt{\%Identifier}), $\mathsf{type}$ to the set of types in a given program (related to the Parser symbol \texttt{Type}), and $\{c,m\}$ to the mutability of the object: $c$ represents an immutable value (as declared by \code{let}), and $m$ a mutable one (declared by \code{mut}).
		
		The symbol $\in$ is defined as follows: $s\in S \Leftrightarrow \textnormal{$s$ is contained in \textit{any} layer of $S$}$, whereas $\in_0$ is true only if the symbol is at the top level of the symbol stack (i.e. defined in the same block). The operator $\cup$ on $S$ adds another binding to the top layer of the stack, whereas $\sqcup$ adds another layer to the stack.
		
		The following are the typing rules for Dromedar programs:
		
		\subsection{Subtyping Rules}
		
			\subsubsection{Trivial Rule}
			
				\begin{align*}
					\drmrule{}{}{T}{\mc{t} \preceq \mc{t}}{SubTyTrivial}
				\end{align*}
				
			\subsubsection{References}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{t1} \preceq \mc{t2}}{}{T}{\mc{t1} \preceq \mc{t2?}}{SubTyRefs},\ \ 
					\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{t2}}{}{T}{\mc{t1?} \preceq \mc{t2?}}{SubTyRefs}
				\end{align*}
				
			\subsubsection{Arrays}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{t2}}{}{T}{\mc{[t1]}\preceq\mc{[t2]}}{SubTyFuns}
				\end{align*}
		
			\subsubsection{Functions}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{u1}\preceq\mc{t1},\ \dots,\ \ruleapp{T}\mc{un}\preceq\mc{tn}\ \ \ruleapp{T}\mc{rt}\preceq\mc{ru}}{}{T}{\mc{(t1,...,tn)->rt} \preceq \mc{(u1,...,un)->ru}}{SubTyFuncs}
				\end{align*}
				
			\subsubsection{Subtypes and Supertypes}
			
				The functions $\mathsf{subtys}$ and $\mathsf{suptys}$ of $\mathsf{types}\to\mathcal{P}(\mathsf{types})$ compute the sub- and supertype set of the input type, respectively.
				
				They are used -- among others -- in the \textsc{ExpLitArr} rule.
				
				\begin{align*}
					\mathsf{subtys} &:=
						\left\{
							\begin{array}{lll}
								\mc{int} & \mapsto & \{\mc{int}\}\\
								\mc{flt} & \mapsto & \{\mc{flt}\}\\
								\mc{char} & \mapsto & \{\mc{char}\}\\
								\mc{bool} & \mapsto & \{\mc{bool}\}\\
								\mc{string} & \mapsto & \{\mc{string}\}\\
								\mc{t?} & \mapsto & \{\mc{u},\mc{u?} \;\mid\; \mc{u}\in\mathsf{subtys}(\mc{t})\}\\
								\mc{[t]} & \mapsto & \{\mc{[u]} \;\mid\; \mc{u}\in\mathsf{subtys}(\mc{t})\}\\
								\mc{(t1...tn)->rt} & \mapsto &
									\{\mc{(u1...un)->st} \;\mid\; \mc{u1...un}\in\mathsf{suptys}(\mc{t1...tn}),\mc{st}\in\mathsf{subtys}(\mc{rt})\}
							\end{array}
						\right.\\
					\mathsf{suptys} &:=
						\left\{
							\begin{array}{lll}
								\mc{int} & \mapsto & \{\mc{int}\}\\
								\mc{flt} & \mapsto & \{\mc{flt}\}\\
								\mc{char} & \mapsto & \{\mc{char}\}\\
								\mc{bool} & \mapsto & \{\mc{bool}\}\\
								\mc{string} & \mapsto & \{\mc{string},\mc{string?}\}\\
								\mc{t?} & \mapsto & \{\mc{u?} \;\mid\; \mc{u}\in\mathsf{suptys}(\mc{t})\}\\
								\mc{[t]} & \mapsto & \{\mc{[u]}, \mc{[u]?} \;\mid\; \mc{u}\in\mathsf{suptys}(\mc{t})\}\\
								\mc{(t1...tn)->rt} & \mapsto &
									\left[
									\begin{array}{l}
										\{\mc{(u1...un)->st},\mc{((u1...un)->st)?} \\\ \ \;\mid\; \mc{u1...un}\in\mathsf{subtys}(\mc{t1...tn}),\mc{st}\in\mathsf{suptys}(\mc{rt})\}
									\end{array}
									\right.
							\end{array}
						\right.
				\end{align*}
		
		\subsection{Builtin Operators}
		
			Many builtin operators are overloaded, providing functionality for multiple input types.
			
			\subsubsection{Unary Operators}
			
				\subsubsubsection{Arithmetic Negation}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{-} :: \mc{int->int}}{TyUopNegInt},\ \ 
						\drmrule{}{}{O}{\mc{-} :: \mc{flt->flt}}{TyUopNegInt}
					\end{align*}
				
				\subsubsubsection{Logical Negation}

					\begin{align*}
						\drmrule{}{}{O}{\mc{!} :: \mc{bool->bool}}{TyUopNot}
					\end{align*}
			
			\subsubsection{Binary Operators}
			
				\subsubsubsection{Power}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{**} :: \mc{(int,int)->int}}{TyBopPowInt},\ \ 
						\drmrule{}{}{O}{\mc{**} :: \mc{(flt,flt)->flt}}{tyBopPowFlt}
					\end{align*}
				
				\subsubsubsection{Multiplication}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{*} :: \mc{(int,int)->int}}{TyBopMulInt},\ \ 
						\drmrule{}{}{O}{\mc{*} :: \mc{(flt,flt)->flt}}{TyBopMulInt}
					\end{align*}
				
				\subsubsubsection{Addition and Subtraction}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,int)->int}}{TyBopAddInt},\ \ &
								\drmrule{}{}{O}{\mc{+} :: \mc{(flt,flt)->flt}}{TyBopAddFlt},\\
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,char)->char}}{TyBopAddCharR},\ \ &
								\drmrule{}{}{O}{\mc{+} :: \mc{(char,int)->char}}{TyBopAddCharL}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,int)->int}}{TyBopSubInt},\ \ &
								\drmrule{}{}{O}{\mc{-} :: \mc{(flt,flt)->flt}}{TyBopSubFlt},\\
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,char)->char}}{TyBopSubCharR},\ \ &
								\drmrule{}{}{O}{\mc{-} :: \mc{(char,int)->char}}{TyBopSubCharL}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Shift Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{<<} :: \mc{(int,int)->int}}{TyBopLShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{>>} :: \mc{(int,int)->int}}{TyBopBitRShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{>>>} :: \mc{(int,int)->int}}{TyBopBitAShift}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Bitwise Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{\&} :: \mc{(int,int)->int}}{TyBopBitAnd}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{^} :: \mc{(int,int)->int}}{TyBopXor}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{|} :: \mc{(int,int)->int}}{TyBopBitOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Logical Operators}
				
					\begin{itemize}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{\&\&} :: \mc{(bool,bool)->bool}}{TyBopLogAnd}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{\^\^} :: \mc{(bool,bool)->bool}}{TyBopLogXor}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{||} :: \mc{(bool,bool)->bool}}{TyBopLogOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Comparison Operators}
				
					\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(int,...,int)->bool}}{TyCmpListInt},\\
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(flt,...,flt)->bool}}{TyCmpListFlt},\\
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(char,...,char)->bool}}{TyCmpListChar},\\
					\end{align*}
					
					
		\subsection{Expressions}
		
			\subsubsection{Subtyping Expression Rule}
			
				To reduce tree rules, we define the following rules:
				
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1}\ \ \ruleapp{T}\mc{t1}\preceq\mc{t}}{S}{ET}{\mc{exp} \trianglelefteq \mc{t}}{ExpSubLocal},\ \ 
					\drmrule{S\ruleapp{G}\mc{exp}::\mc{t1}\ \ \ruleapp{T}\mc{t1}\preceq\mc{t}}{S}{GT}{\mc{exp} \trianglelefteq \mc{t}}{ExpSubGlobal}
				\end{align*}
		
			\subsubsection{Assignability}
			
				The rule $\ruleapp{A}$ defines when an expression can be assigned a value.
				
				\begin{align*}
					\drmrule{(\mc{id},\_,m)\in S}{S}{A}{\mc{id}}{ExpAssnId},\ \ 
					\drmrule{S\ruleapp{A}\mc{e1}}{S}{A}{\mc{e1[e2]}}{ExpAssnSub}
				\end{align*}
				
			\subsubsection{Global Expressions}
			
				The rule $\vdash_G$ describes global expressions, which are restricted in a way that they can be computed at compile time. Global variables are also strictly non-\code{null}.
				
				The following copied rules use $\vdash_G$ instead of $\vdash_E$
				
				\subsubsubsection{Literals}
				
					\begin{itemize}
						\item \textsc{GExpLitInt} $:=$ \textsc{ExpLitInt}
						\item \textsc{GExpLitFlt} $:=$ \textsc{ExpLitFlt}
						\item \textsc{GExpLitChar} $:=$ \textsc{ExpLitChar}
						\item \textsc{GExpLitBool} $:=$ \textsc{ExpLitBool}
					\end{itemize}
				
				\subsubsubsection{Other Rules}
				
					\begin{itemize}
						\item \textsc{GExpId} $:=$ \textsc{ExpId}
						\item \textsc{GExpUop} $:=$ \textsc{ExpUop}
						\item \textsc{GExpBop} $:=$ \textsc{ExpBop}
						\item \textsc{GExpCmpList} $:=$ \textsc{ExpCmpList}
					\end{itemize}
				
					Note that global variable declarations cannot feature function calls or \code{null} declarations.
		
			\subsubsection{Literals}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{}{}{E}{n :: \mc{int}}{ExpLitInt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{f :: \mc{flt}}{ExpLitFlt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{c :: \mc{char}}{ExpLitChar}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{\mc{true} :: \mc{bool}}{ExpLitBoolTrue},\ \ 
							\drmrule{}{}{E}{\mc{false} :: \mc{bool}}{ExpLitBoolFalse}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{}{E}{s :: \mc{string}}{ExpLitString}
						\end{align*}
					\item
						In arrays, the typechecker looks for the common subtypes of all array literal elements and looks for the one type \code{t} that is a supertype of all elements and which is a subtype of all other such subtypes (the minimum of the subtypes given the $\preceq$ relation on types).
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{e1}::\mc{t1},\ \dots,\ S\ruleapp{E}\mc{en}::\mc{tn}\ \ \mc{t} = \min_\preceq (\bigcap_{\mc{i}=\mc{1}}^{\mc{n}}\mathsf{suptys}(\mc{ti}))}{S}{E}{\mc{[e1,...,en]} :: \mc{[t]}}{ExpLitArr}
						\end{align*}
						
						Because the graph connecting types and subtypes is a forest of trees, if the intersection of supertypes is nonempty there is a unique solution \code{t}.
				\end{itemize}
			
			\subsubsection{Null}
			
				\begin{align*}
					\drmrule{\textnormal{\code{t} is a non-null ref. type}}{S}{E}{\mc{null of t} :: \mc{t?}}{ExpNull}
				\end{align*}
			
			\subsubsection{Identifiers}
			
				\begin{align*}
					\drmrule{(id,\mc{t},\_)\in S}{S}{E}{\mc{id} :: \mc{t}}{ExpId}
				\end{align*}
			
			\subsubsection{Unary Operations}
			
				Unary and Binary Operations do not need to do subtype checking, as they operate only on primitives.
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1}\ \ \ruleapp{O}\mc{op}::\mc{t1->t}}{S}{E}{\mc{op exp}::\mc{t}}{ExpUop}
				\end{align*}
			
			\subsubsection{Binary Operations}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e1}::\mc{t1}\ \ S\ruleapp{ET}\mc{e2}::\mc{t2}\ \ \ruleapp{O}\mc{op}::\mc{(t1,t2)->t}}{S}{E}{\mc{e1 op e2} :: \mc{t}}{ExpBop}
				\end{align*}
			
			\subsubsection{Function Calls}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{f}::\mc{(t1,...,tn)->rt}\ \ \mc{rt}\not\equiv\mc{void}\ \  S\ruleapp{ET}\mc{e1}\trianglelefteq\mc{t1},\ \dots,\ S\ruleapp{ET}\mc{en}\trianglelefteq\mc{tn}}{S}{E}{\mc{f(e1,...,en)}::\mc{rt}}{ExpFunc}´
				\end{align*}
				
			\subsubsection{Subscript Access}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{s}::\mc{string}\ \ S\ruleapp{E}\mc{i}::\mc{int}}{S}{E}{\mc{s[i]} :: \mc{char}}{ExpArrSub}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{e}::\mc{[t]}\ \ S\ruleapp{E}\mc{i}::\mc{int}}{S}{E}{\mc{e[i]} :: \mc{t}}{ExpArrSub}
						\end{align*}
				\end{itemize}
			
			\subsubsection{Comparison Lists}
			
				\begin{align*}
					\drmrule{\ruleapp{O}\mc{op1}::\mc{(t0,t1)->t},\ \dots,\ \ruleapp{O}\mc{opn}::\mc{(t(n-1),tn)->t}\ \ S\ruleapp{ET}\mc{e0}\trianglelefteq\mc{t0},\ \dots,\ S\ruleapp{ET}\mc{en}\trianglelefteq\mc{tn}}{S}{E}{\mc{e0 op1 ... opn en} :: \mc{t}}{ExpCmpList}
				\end{align*}
				
		\subsection{Statements}
		
			In the statement typing rules, a statement rule produces a tuple $(S,r)$ where $S$ stands for the newly updated context, and $r\in\{\bot,\top\}$, where $\bot$ means that a statement might not return and $\top$ means that a statement definitely returns.
			
			To prevent potential mistakes, the typechecker prevents statements which are deemed unreachable at compile time. The logical operators $\vee$ and $\wedge$ operate as if $\bot\equiv0$ and $\top\equiv1$.
		
			\subsubsection{Local Variable Declarations}
			
				\begin{align*}
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{E}\mc{exp} :: \mc{t}}{S,\mc{rt}}{S}{\mc{let id := exp} \Rightarrow (S \cup (\mc{id},\mc{t},c)),\bot}{StmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{t}}{S,\mc{rt}}{S}{\mc{let id:t := exp} \Rightarrow (S \cup (\mc{id},\mc{t},c)),\bot}{StmtVTDeclConst}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{E}\mc{exp} :: \mc{t}}{S,\mc{rt}}{S}{\mc{mut id := exp} \Rightarrow (S \cup (\mc{id},\mc{t},m)),\bot}{StmtVDeclMut}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{t}}{S,\mc{rt}}{S}{\mc{mut id:t := exp} \Rightarrow (S \cup (\mc{id},\mc{t},m)),\bot}{StmtVTDeclMut}
				\end{align*}
			
			\subsubsection{Assignments}
			
				\begin{align*}
					\drmrule{S\ruleapp{A}\mc{lhs}\ \ S\ruleapp{E}\mc{lhs} :: \mc{t}\ \ S\ruleapp{ET}\mc{exp} \trianglelefteq \mc{t}}{S,\mc{rt}}{S}{\mc{lhs := exp} \Rightarrow S,\bot}{StmtAssn}
				\end{align*}
			
			\subsubsection{Expression Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp} :: \mc{t}}{S,\mc{rt}}{S}{\mc{exp} \Rightarrow S,\bot}{StmtExpr}\ \ \drmrule{S\ruleapp{E}\mc{(t1,...,tn)->void}}{S,\mc{rt}}{S}{\mc{exp(a1,...,an)} \Rightarrow S,\bot}{StmtExprVoid}
				\end{align*}
			
			\subsubsection{If Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,\mc{rt}\ruleapp{S}\mc{b1}\Rightarrow S_1,R_1\ \ S,\mc{rt}\ruleapp{S}\mc{b2}\Rightarrow S_2,R_2}{S,\mc{rt}}{S}{\mc{if c b1 else b2} \Rightarrow S,R_1\wedge R_2}{StmtIf}
				\end{align*}
			
			\subsubsection{While Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,\mc{rt}\ruleapp{S}\mc{b}\Rightarrow S',R}{S,\mc{rt}}{S}{\mc{while c b} \Rightarrow S,\bot}{StmtWhile}
				\end{align*}
			
			\subsubsection{Do-While Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,\mc{rt}\ruleapp{S}\mc{b}\Rightarrow S',R}{S,\mc{rt}}{S}{\mc{do b while c} \Rightarrow S,R}{StmtDoWhile}
				\end{align*}
				
			\subsubsection{For Statements}
	
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{estart}::\mc{int}\ \ S\ruleapp{E}\mc{eend}::\mc{int}\ \ S\cup \{ (\mc{id},\mc{int},c) \},\mc{rt}\ruleapp{S} \mc{b}\Rightarrow S',R}{S,\mc{rt}}{S}{\mc{for id := estart \%ForSpecifier eend b} \Rightarrow S,\bot}{StmtFor}
				\end{align*}
			
			\subsubsection{Return Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{rt}}{S,\mc{rt}}{S}{\mc{return exp} \Rightarrow S,\top}{StmtReturnExp},\ \  \drmrule{}{S,\mc{void}}{S}{\mc{return}\Rightarrow S,\top}{StmtReturn}
				\end{align*}
				
			\subsubsection{Blocks}
			
				\begin{align*}
					\drmrule{S\sqcup\{\},\mc{rt}\ruleapp{S}\mc{s1} \Rightarrow S_1,\bot,\ \ S_1,\mc{rt}\ruleapp{S}\mc{s2} \Rightarrow S_2,\bot,\ \dots,\ S_{n-1},\mc{rt}\ruleapp{S}\mc{sn} \Rightarrow S_n,R}{S,\mc{rt}}{S}{\mc{s1 ... sn} \Rightarrow S_n,R}{StmtBlock}
				\end{align*}
		
		\subsection{Global Statements}
		
			\subsubsection{Global Function Declaration}
			
				\begin{align*}
					\drmrule{S\sqcup\{(\mc{a1},\mc{t1},c),\dots,(\mc{an},\mc{tn},c)\},\mc{rt} \ruleapp{S} \mc{b} \Rightarrow S',\top\;(\textnormal{or \code{rt=void}}) \ \ \mc{a1},\dots,\mc{an} \textnormal{ distinct}}{S}{G}{\mc{fn id : a1:t1, ..., an:tn -> rt b} \Rightarrow S}{GStmtFDecl}
				\end{align*}
			
			\subsubsection{Global Variable Declaration}
			
				\begin{align*}
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{G}\mc{exp} :: \mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S}{G}{\mc{global id := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\}}{GStmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{GT}\mc{exp}\trianglelefteq\mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S}{G}{\mc{global id:t := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\}}{GStmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{G}\mc{exp} :: \mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S}{G}{\mc{global mut id := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},m)\}}{GStmtVDeclMut}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{GT}\mc{exp}\trianglelefteq\mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S}{G}{\mc{global mut id:t := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},m)\}}{GStmtVDeclMut}
				\end{align*}
			
			\subsubsection{Program}
			
				\begin{align*}
					\drmrule{S_0 \ruleapp{G} \mc{gs1} \Rightarrow S_1,\ \dots,\ S_{n-1} \ruleapp{G} \mc{gsn} \Rightarrow S_n}{S_0}{G}{\mc{gs1 ... gsn} \Rightarrow S_n}{GStmtProgram}
				\end{align*}
				
		\subsection{Context Buildup}
		
			\subsubsection{Global Function Declarations}
			
				\begin{align*}
					\drmrule{(\mc{id},\_) \not\in S}{S}{GCF}{\mc{fn id : a1:t1, ..., an:tn -> rt b} \Rightarrow S \cup (\mc{id}, \mc{(t1,...,tn)->rt}, c)}{GStmtFCtxtFDecl}
				\end{align*}
				\begin{align*}
					\drmrule{}{S}{GCF}{\mc{global id := exp} \Rightarrow S}{GStmtFCtxtVDeclConst}\\
					\drmrule{}{S}{GCF}{\mc{global id:t := exp} \Rightarrow S}{GStmtFCtxtVTDeclConst}\\
					\drmrule{}{S}{GCF}{\mc{global mut id := exp} \Rightarrow S}{GStmtFCtxtVDeclMut}\\
					\drmrule{}{S}{GCF}{\mc{global mut id:t := exp} \Rightarrow S}{GStmtFCtxtVTDeclMut}
				\end{align*}
			
			\subsubsection{Program: Functions}
			
				\begin{align*}
					\drmrule{S_0 \ruleapp{GCF} \mc{gs1} \Rightarrow S_1,\ \dots,\ S_{n-1} \ruleapp{GCF} \mc{gsn} \Rightarrow S_n}{S_0}{GC}{\mc{gs1 ... gsn} \Rightarrow S_n}{GStmtCtxtFuncs}
				\end{align*}
			
		\subsection{Rule for Program Typechecking}
		
			Let $S^\star$ be the starting context which contains the builtin context. It looks as follows:
			
			\begin{align*}
				S^\star := \{\}\sqcup \left\{
					\begin{array}{lll}
						(\mc{string\_of\_int},&\mc{int -> string},&c),\\ (\mc{string\_of\_flt},&\mc{flt -> string},&c),\\
						(\mc{string\_concat},&\mc{(string,string) -> string},&c),\\
						(\mc{io\_print},&\mc{string -> void},&c)
					\end{array}
				\right\}
			\end{align*}
		
			\begin{align*}
				\drmrule{S^\star \ruleapp{GC} \mc{prog} \Rightarrow S' \ \ S' \ruleapp{G} \mc{prog} \Rightarrow S}{}{}{\mc{prog}}{Prog}
			\end{align*}
		
	\section{Formal Grammar}
	
		\subsection{Lexer Grammar}
		
			The Lexer Grammar is specified using \textbf{regular expressions}:
			
			\begin{verbatim}
				LiteralInt   ::= /[1-9]\d*/
				LiteralFlt   ::= /\d+\.\d+/
				LiteralChar  ::= /'([^'\\]|(\\[\\nrt']))'/
				LiteralBool  ::= /true|false/
				LiteralStr   ::= /"([^"\\]|(\\[\\nrt"]))*"/
				
				Identifier   ::= /[a-zA-Z][a-zA-Z0-9_]*/
				
				global       ::= /global/
				fn           ::= /fn/
				let          ::= /let/
				mut          ::= /mut/
				
				int          ::= /int/
				flt          ::= /flt/
				char         ::= /char/
				bool         ::= /bool/
				string       ::= /string/
				void         ::= /void/
				
				null         ::= /null/
				of           ::= /of/
				
				if           ::= /if/
				elif         ::= /elif/
				else         ::= /else/
				do           ::= /do/
				while        ::= /while/
				for          ::= /for/
				 
				return       ::= /return/
				
				Dash         ::= /\-/
				Bang         ::= /!/
				Star         ::= /\*/
				Plus         ::= /\+/
				LShift       ::= /<</
				RShift       ::= />>/
				AShift       ::= />>>/
				Bitand       ::= /&/
				Xor          ::= /\^/
				Bitor        ::= /\|/
				Logand       ::= /&&/
				Logor        ::= /\|\|/
				
				Equal        ::= /=/
				NotEqual     ::= /!=/
				Greater      ::= />/
				Less         ::= /</
				GreaterEq    ::= />=/
				LessEq       ::= /<=/
				
				Assign       ::= /:=/
				
				Colon        ::= /:/
				Arrow        ::= /\->/
				
				Comma        ::= /\,/
				
				Dots         ::= /\.\.\./
				DotsPipe     ::= /\.\.\|/
				PipeDots     ::= /\|\.\./
				PipeDotPipe  ::= /\|\.\|/
				
				LParen       ::= /\(/
				RParen       ::= /\)/
				LBrack       ::= /\[/
				RBrack       ::= /\]/
				
				QuestionMark ::= /\?/
			\end{verbatim}
			
		\subsection{Parser Grammar}
		
			The following grammar specification uses a preceding \texttt{\%} for lexer tokens.
		
			\begin{verbatim}
				Program          ::=
				                 | €
				                 | GlobalStatement Program
				                 
				GlobalStatement  ::=
				                 | GVDeclaration
				                 | GFDeclaration
				                 
				GVDeclaration    ::=
				                 | %Global      %Identifier             %Assign GlobalExpression
				                 | %Global      %Identifier %Colon Type %Assign GlobalExpression
				                 | %Global %Mut %Identifier             %Assign GlobalExpression
				                 | %Global %Mut %Identifier %Colon Type %Assign GlobalExpression
				                 
				GFDeclaration    ::=
				                 | %Fn %Identifier                   %Arrow ReturnType Block
				                 | %Fn %Identifier %Colon FArguments %Arrow ReturnType Block
				                 
				FArguments       ::=
				                 | %Identifier %Colon Type
				                 | %Identifier %Colon Type %Comma FArguments
				
				ReturnType       ::=
				                 | %Void
				                 | Type
				                 
				Block            ::=
				                 | €
				                 | Statement Block
				
				Statement        ::=
				                 | VDeclaration
				                 | AssignStmt
				                 | IfStmt
				                 | WhileStmt
				                 | DoWhileStmt
				                 | ForStmt
				                 | ExprStmt
				                 | ReturnStmt
				                 
				VDeclaration     ::=
				                 | %Let %Identifier             %Assign Expression
				                 | %Let %Identifier %Colon Type %Assign Expression
				                 | %Mut %Identifier             %Assign Expression
				                 | %Mut %Identifier %Colon Type %Assign Expression
				                 
				AssignStmt       ::=
				                 | LHS %Assign Expression
				                 
				IfStmt           ::=
				                 | %If Expression Block ElifStmt
				                 
				ElifStmt         ::=
				                 | %Elif Expression Block ElifStmt
				                 | %Else Block
				                 | €
				                 
				WhileStmt        ::=
				                 | %While Expression Block
				
				DoWhileStmt      ::=
				                 | %Do Block %While Expression
				                 
				ForStmt          ::=
				                 | %For %Id %Assign Expr ForSpecifier Expr Block
				                 
				ForSpecifier     ::=
				                 | %Dots
				                 | %DotsPipe
				                 | %PipeDots
				                 | %PipeDotPipe
				                 
				ExprStmt         ::=
				                 | Expression
				                 | Expression %Colon FArgs
				                 
				ReturnStmt       ::=
				                 | %Return
				                 | %Return Expression
				                 
				LHS              ::=
				                 | %Identifier
				                 
				Type             ::=
				                 | %Int
				                 | %Flt
				                 | %Char
				                 | %Bool
				                 | RefType
				                 | RefType %QuestionMark
				                 
				RefType          ::=
				                 | %Str
				                 | %LBrack Type %RBrack
				                 
				GlobalExpression ::= Expression*
			
				Expression       ::=
				                 | %Null %Of RefType
				                 | %LBrack %RBrack %Of Type
				                 | ExprPrec30
				
				ExprPrec20       ::= 
				                 | ExprPrec30
				                 | ExprPrec30 %Equal     ExprPrec20
				                 | ExprPrec30 %NotEqual  ExprPrec20
				                 | ExprPrec30 %Greater   ExprPrec20
				                 | ExprPrec30 %Less      ExprPrec20
				                 | ExprPrec30 %GreaterEq ExprPrec20
				                 | ExprPrec30 %LessEq    ExprPrec20
				ExprPrec30       ::=
				                 | ExprPrec40
				                 | ExprPrec40 %Bitor ExprPrec30
				ExprPrec40       ::=
				                 | ExprPrec50
				                 | ExprPrec50 %Xor ExprPrec40
				ExprPrec50       ::=
				                 | ExprPrec60
				                 | ExprPrec60 %Bitand ExprPrec50
				ExprPrec60       ::=
				                 | ExprPrec70
				                 | ExprPrec70 %LShift ExprPrec60
				                 | ExprPrec70 %RShift ExprPrec60
				                 | ExprPrec70 %AShift ExprPrec60
				ExprPrec70       ::=
				                 | ExprPrec80
				                 | ExprPrec80 %Plus ExprPrec70
				                 | ExprPrec80 %Minus ExprPrec70
				ExprPrec80       ::=
				                 | ExprPrec90
				                 | ExprPrec90 %Star ExprPrec80
				ExprPrec90       ::=
				                 | ExprPrec100
				                 | ExprPrec100 %StarStar ExprPrec90
				ExprPrec100      ::=
				                 | SimpleExpression
				                 | %Dash ExprPrec100
				                 | %Bang ExprPrec100
				                 
				SimpleExpression ::=
				                 | BaseExpression Application
				                 | BaseExpression
				
				BaseExpression   ::=
				                 | %LParen Expression %RParen
				                 | %LBrack CommaExpList %RBrack
				                 | %LiteralInt
				                 | %LiteralFlt
				                 | %LiteralChar
				                 | %LiteralBool
				                 | %LiteralStr
				                 | %Identifier
				                 
				Application      ::=
				                 | %LParen CommaExpListNE %RParen
				                 | %LBrack Expression %RBrack
				
				CommaExpList     ::=
				                 | €
				                 | CommaExpListNE
				CommaExpListNE   ::=
				                 | Expression
				                 | Expression %Comma CommaExpListNE
			\end{verbatim}
	
\end{document}






















