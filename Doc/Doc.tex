\documentclass{article}

\usepackage{listings, xcolor, enumitem, hyperref, multicol, booktabs, longtable, titlesec, amssymb, amsmath}

\usepackage{sourcecodepro}
\usepackage[T1]{fontenc}

\usepackage[margin=2cm,a4paper]{geometry}

\DeclareFontShape{OT1}{cmtt}{bx}{n}{<5><6><7><8><9><10><10.95><12><14.4><17.28><20.74><24.88>cmttb10}{}

\lstdefinelanguage{Dromedar}{
	morekeywords = [1]{type,int,flt,char,bool,void,fn,string},
	morekeywords = [2]{true,false,null},
	morekeywords = [3]{return,if,else,while,do,for,denull,break,continue},
	morekeywords = [4]{let,mut,global},
	morekeywords = [5]{of,in},
	morekeywords = [6]{printf,sprintf,assert},
	morekeywords = [7]{module,native},
	morekeywords = [8]{Str,IO,Util,File,Math,Regex,Sys,Time},
	morekeywords = [9]{main,of_int,of_flt,print_int,print_flt,print_char,print_bool,print_char,print_str,randint,randflt,readall,sin,cos,tan,e,pi,compile,matches,first_match,all_matches,cmd,fork,clock,time,sleep_for,now,dt,s,ms,us,of_s,of_ms,of_us},
	comment = [l]{\#},
	%morecomment = [s]{/*}{*/},
	string = [b]',
	morestring = [b]"
}

\lstset{
	language=Dromedar,
	nolol=false,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	xleftmargin=\parindent,
	framexleftmargin=0.2em,
	belowskip=0.6em,
	%basewidth=0.5em,
	backgroundcolor=\color{white!90!black},
	emphstyle=\bfseries\slshape,
	basicstyle=\ttfamily\color{black},
	keywordstyle=\bfseries,
	keywordstyle=[3]\bfseries\color{black!20!purple},
	keywordstyle=[6]\bfseries\color{black!60!blue},
	keywordstyle=[8]\color{black!60!red},
	keywordstyle=[9]\color{black!60!blue}\itshape,
	commentstyle=\color{gray},
	stringstyle=\slshape,
	showstringspaces=false,
	tabsize=4
}

\renewcommand{\c}[1]{\texttt{#1}}
\newcommand{\code}[1]{\lstinline[columns=fixed]{#1}}

\newcommand{\drmrule}[5]{\frac{#1}{#2\vdash_{\mathsf{#3}}#4}\textsc{\ \small{#5}}}

\newcommand{\ruleapp}[1]{\vdash_{\mathsf{#1}}}
\newcommand{\mc}[1]{\textnormal{\code{#1}}}

\newcommand{\parw}{9cm}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\subsubsubsection}{\paragraph}

\begin{document}
	
	\vfill
	\begin{center}
		\large{Oliver Graf}\\
		\vspace{5cm}
		\large{\textsc{The}}\\\vspace{1cm}
		\Huge{\textsc{Dromedar}}\\\vspace{1cm}
		\large{\textsc{Programming Language}}
	\end{center}
	\vfill
	
	\clearpage
	
	\setcounter{tocdepth}{1}
	\tableofcontents
	\clearpage
	
	\section{Introduction}
	
		Dromedar is a statically typed, garbage collected, \textit{safe} programming language. It is mainly imperative, but combines these constructs with some typically functional language elements like partial application.
			
	\section{Language Tutorial}
	
		\subsection{Hello, World!}
		
			Each Dromedar program contains a \code{main} function that serves as the start point of the execution of the program. The function is denoted by the keyword \code{fn}, its return type is specified after the arrow: \code{void} means that the function doesn't return a value.
			
			In order to print \textit{Hello, World!} to the console, the program calls the function \code{print\_str} from the standard library module \code{IO}.
		
			\begin{lstlisting}
fn main -> void
	IO.print_str("Hello, World!\n")
			\end{lstlisting}
			
			Using the \textsc{Droml} compiler, the program can be compiled and executed with the following command:
			
			\begin{verbatim}
				droml -o app <FILENAME>.drm
				./app
			\end{verbatim}
			
		\subsection{Types}
		
			Dromedar knows two families of types: Primitive \textit{value} types and \textit{reference} types. Value types are small types that are stored on the stack, whereas reference types are garbage-collected objects on the heap.
			
			Value types include the following: \code{bool} (for truth values \code{true} and \code{false}), \code{char} (for 1-byte characters represented in single quotes), \code{int} (for 64-bit signed integers), and \code{flt} (64-bit real numbers). Reference types come in two classes: Definitely-not-\code{null}, and Maybe-\code{null} types (as denoted by a \code{?} following the type name).
			
			There are two categories of reference types: Arrays and \code{string}s. Arrays are denoted by the element type, enclosed in square brackets. For example, \code{[int]} represents an integer array, whereas \code{[[[char]]]} stands for a three-dimensional character array. \code{string} represents a string of characters, \code{string?} represents values which are either \code{string} objects, or \code{null} -- a state used for values which do not represent any object.
			
			These types can be nested within arrays: \code{[[[[string]?]]?]?} is a maybe-\code{null} array of maybe-\code{null} arrays containing two-dimensional arrays of maybe-\code{null} string arrays.
			
			Functions are also handled as reference types.
			
			It is not possible to access objects of maybe-null types in order to ensure null pointer safety. More on maybe-null reference types in later sections in this tutorial.
			
			\subsubsection{Subtypes and Crosstypes}
			
				Consider the subtype relation $\prec$ and the crosstype commutation relation $\asymp$, as defined in the section on the typing rules.
				
				These relations define which type of values can be assigned to variables of certain types (and passed as function arguments, and so on).
				
				These typing relations are more precisely explained in the typing rule section. Here a quick summary:
				
				Non-\code{null} types are subtypes of their corresponding maybe-\code{null} types, e.g. meaning that a non-\code{null} string expression (such as a string literal) can be assigned to a variable of type \code{string?}. The same goes for arrays.
				
				Integers and real numbers are cross-types, meaning that it is possible to assign a real number to an integer variable. In that case, the real number is cast to an integer before the assignment takes place.
			
		\subsection{Expressions}
		
			Dromedar knows the typical mathematical expressions and precedence rules as known by most programming languages in the C family. The precise types of the different operators are explained in detail in the section on the typing rules. Here is a quick summary:
			
			Apart from \code{+}, \code{-}, \code{*}, \code{/}, \code{\%}, the shifting operators \code{<<}, \code{>>}, and \code{>>>}, the bitwise operators \code{\&}, \code{|}, \code{^}, and the logical operators \code{\&\&} and \code{||} using short-circuit evaluation, the language also knows \code{**} for exponentiation, and \code{^}\code{^} for boolean (instead of bitwise) exclusive or.
			
			Dromedar also allows comparisons using the operators \code{=}, \code{!=}, \code{>}, \code{>=}, \code{<}, and \code{<=}, and allows combining them into comparison chains. For example, \code{3 < 5 < 7 >= 3} is a legal expression which returns \code{true} since every sub-comparison is true. Each expression in such a chain is only evaluated once and the entire comparison list is short-circuited. The first comparison that is false cuts off the rest of the evaluation, as with the \code{\&\&} and \code{||} operators.
			
			The operators \code{==} and \code{!==} do reference comparison: They check whether two references point at the same object, not whether these objects are structurally identical. Reference Equality thus implies structural equality, but not the other way around.
			
			Dromedar also knows the unary operators \code{-} and \code{!} for arithmetic and logical negation.
			
			These operators take pairs of the following types: \code{flt,flt} and \code{int,int} for the arithmetic, \code{int,int} for the bitwise, and \code{bool,bool} for the logical operators. The arithmetic operators also allow for mixing of \code{flt} and \code{int}, where such an operation will always cast the integer to a real number and then perform the operation.
			
			Addition and subtraction also allow adding and subtracting from \code{char} values using integers.
			
			The \code{+} operator is also used for string and array concatenation, the \code{*} operator can also perform string repetition (e.g. \code{2 * "hi" ==> "hihi"}).
	
		\subsection{Variables, Assignments}
		
			\subsubsection{Global Variables}
			
				Global variables are declared and assigned outside of function bodies. Their assignment expressions are quite restricted: Only value type and string literals are allowed thus far.
				
				These variables are reachable in all code below the point of their initialization.
				
				Global variables are declared using the \code{global} keyword, with the following syntax:
				
				\begin{verbatim}
					global [mut] identifier [: type] := expression
				\end{verbatim}
				
				Consider the following global variable declarations:
				
				\begin{lstlisting}
global     x      := 3
global     y :int := 7.2
global mut s      := "hi!"
				\end{lstlisting}
				
				The two variables \code{x} and \code{y} are immutable constants -- their value can never be changed. The string \code{s} however can be changed to hold any other string reference, as it was declared \code{mut}.
				
				Because the type of \code{y} was specified \code{int}, the value it was assigned to is cast to an integer before the assignment.
				
			\subsubsection{Local Variables}
			
				Local Variables are declared using the \code{let} keyword, or just \code{mut} for mutable variables. They can be of any type and the values they are assigned to can be arbitrarily complex expressions. Consider the following local variable declarations:
				
				\begin{lstlisting}
let x            := 9
let y  :flt      := x ** 7
mut s1 :string?  := null
let s2 :string?  := "hi!"
let a  :[[int]?] := [ null, [] ]
				\end{lstlisting}
				
				\begin{itemize}
					\item
						\code{x} is an immutable integer holding the value \code{7}.
					\item
						\code{y} is a floating point number holding the value \code{x ** 7 == 4782969}, which is then implicitly cast to a \code{flt} value, \code{4782969.0}.
					\item
						\code{s1} is a mutable maybe-null \code{string} value which is assigned \code{null}.
					\item
						\code{s2} is an immutable maybe-null string which contains the value \code{"hi!"}.
					\item
						Finally, \code{a} is an array of maybe-null integer arrays, of which the first value is \code{null} and the second an empty integer list.
				\end{itemize}
			
			\subsubsection{Of \code{null} and empty lists}
			
				\code{null} and empty lists are, per se, typeless. However, Dromedar is strongly typed, doesn't know a base type like \texttt{Object} in Java\textsuperscript{TM}, and it uses type inference in variable declarations.
				
				Thus, in general, the type of \code{null} and the empty list must be specified: \code{null of string} is \code{null} of the type \code{string?}, whereas \code{null of [[[int]]]} is the \code{null} value corresponding to the type \code{[[[int]]]?}. On the other hand, \code{[] of int} is the empty list of \code{int} values, \code{[] of [int]} the empty list of \code{[int]} values (of type \code{[[int]]}).
				
				In some instances however, the type of an empty list or null reference can be ommitted: In a function call where the argument's type is already clear, or in an expression where the type can be strictly inferred: For example, consider the function \code{f: [string]? -> string} and the following code:
				
				\begin{lstlisting}
let s1             := f(null) # infers null of [string]
let s2             := f([])   # infers [] of string
let a  : [[[int]]] := [[]]    # infers [] of [int]
				\end{lstlisting}
		
		\subsection{Conditionals}
		
			The simplest way of decision making and control flow in Dromedar is the \code{if-elif-else} statement, with the following grammar:
			
			\begin{verbatim}
				if expression
				    <BLOCK>
				{
				elif expression
				    <BLOCK>
				}
				[
				else
				    <BLOCK>
				]
			\end{verbatim}
			
			The behaviour of this construct follows most other imperative programming languages.
			
			The condition expression must be of type \code{bool} -- a result of a boolean function, a comparison chain, or a boolean literal \code{true} resp. \code{false}. The number of \code{elif} blocks is arbitrary, and the \code{else} block is optional.
			
			If the first condition expression evaluates to \code{true}, the \code{if} block gets executed, the rest is omitted. If it is \code{false}, the next block is looked at. If evaluation reaches the \code{else} branch (by the \code{if} and all \code{elif} conditions evaluating to \code{false}), it gets executed without first evaluating any condition.
		
		\subsection{Checked Casts, Assertions}
		
			In general, it is not possible to read (i.e. dereference) maybe-\code{null} variables since such a dereference might be dangerous (if the value held by the variable is, in fact, \code{null}). Using a checked cast expression, it is possible to get access to the value held by a maybe-\code{null} expression if it is not \code{null}, as follows:
			
			\begin{lstlisting}
# get_maybe_string: () -> string?
let s := get_maybe_string()
denull ns := s
	printf("string: {0}\n", ns)
else
	IO.print_str("null")
			\end{lstlisting}
			
			The expression that \code{ns} is assigned to can be an arbitrary expression of a maybe-\code{null} type. It doesn't have to be a single variable. Thus, the header of the checked cast also could have been \code{denull ns := get_maybe_string()}.
			
			The first block is executed if \code{s} is not \code{null}. In that case, \code{ns} holds the value of \code{s} and it can be treated as a definitely-not-\code{null} variable. Note that even in this block, \code{s} is still a maybe-\code{null} variable.
			
			The \code{else} block gets executed if \code{s = null}.
			
			This is the only \textbf{safe} way to access a maybe-\code{null}'s internal value. However, for ease of use of the language, it is also possible to ``dereference'' a value using \code{assert}, as follows:
			
			\begin{lstlisting}
let s := get_maybe_string()
let ns := assert s
printf("String: {0}\n", ns)
			\end{lstlisting}
			
			Here, \code{ns} is assigned the value held by \code{s}, if \code{s != null}. If, however, \code{s = null} were to hold, the program immediately terminates with an error message to the console. Therefore, these dangerous casts are only to be used if the programmer is entirely certain that a maybe-\code{null} reference is not \code{null}. An example is the \code{Regex.compile} function of the standard library which returns a \code{null} automaton object if the input string is an illegal expression.
			
			However, if the expression is known at compile time, the programmer can be certain that it isn't faulty.
			
			\subsection{\code{assert} Statements}
			
				For example to ensure the program is given the proper inputs, \code{assert} statements can be used (not to be confused with the \code{assert} expressions mentioned above). They check a boolean condition and terminate if the condition is false with an error message, as follows:
				
				\begin{lstlisting}
let x := 3
assert x > 4
				\end{lstlisting}
				
				This program writes the following error message before aborting:
				
				\begin{verbatim}
					Assertion failure in {(3 > 4)}
					Aborting.
				\end{verbatim}
		
		\subsection{Loops, \code{break} and \code{continue}}
		
			There are four different kinds of loops: \code{while}, \code{do-while}, \code{for} and \code{for-in}.
			
			\subsubsection{\code{while} Loops}
			
				\begin{verbatim}
					while expression
					    <BLOCK>
				\end{verbatim}
				
				The condition expression (of type \code{bool}) is evaluated every time before the body. If the condition holds, the body is executed -- otherwise the loop is terminated and execution continues to the next instruction.
				
			\subsubsection{\code{do-while} Loops}
			
				\begin{verbatim}
					do
					    <BLOCK>
					while expression
				\end{verbatim}
				
				This construct is very similar to the \code{while} loop, except that the condition is evaluated after the loop body is executed. That ensures that the loop body is executed at least once.
				
			\subsubsection{\code{for} Loops}
			
				\begin{verbatim}
					for i := a %rangespec b
					    <BLOCK>
				\end{verbatim}
				
				This loop executes a number of times as determined by the distance between \code{a} and \code{b}, where \code{i} can be used as the loop variable within the block. It cannot be edited, and it is automatically incremented/decremented at the end of one execution of the code block.
				
				The \code{\%rangespec} element in the grammar specification is one of the following four syntactic elements: \code{...}, \code{..|}, \code{|..} or \code{|.|}. \code{...} means that the values of \code{i} start at \code{a} and continue executing up to and including \code{b}. \code{..|} stops at one value before \code{b}, \code{|..} starts at one step after \code{a} but includes \code{b}, and finally \code{|.|} starts at a value after \code{a} and stops one step before it reaches \code{b}.
				
				These loops can count upwards and downwards, and the step direction is automatically inferred. The step length is fixed at \code{1}.
				
				Consider the following six examples:
				
				\begin{lstlisting}
# Example 1
for x := 0 ... 10
	printf("{0}, ", x)

# Example 2
for x := 0 ..| 10
	printf("{0}, ", x)

# Example 3
for x := 0 |.. 10
	printf("{0}, ", x)

# Example 4
for x := 0 |.| 10
	printf("{0}, ", x)

# Example 5
for x := 10 ..| 0
	printf("{0}, ", x)

# Example 6
for x := 0 |.| 1
	printf("{0}, ", x)
				\end{lstlisting}
				
				They produce the following outputs:
				
				\begin{verbatim}
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, # Example 1
					0, 1, 2, 3, 4, 5, 6, 7, 8, 9,     # Example 2
					1, 2, 3, 4, 5, 6, 7, 8, 9, 10,    # Example 3
					1, 2, 3, 4, 5, 6, 7, 8, 9,        # Example 4
					10, 9, 8, 7, 6, 5, 4, 3, 2, 1,    # Example 5
					                                  # Example 6
				\end{verbatim}
				
				The loop boundary expressions \code{a} and \code{b} must be of type \code{int} (or \code{flt} which is a crosstype of \code{int}, in which case the expressions are first cast to \code{int} before they're evaluated). The bounds are also only evaluated once before the first loop iteration.
				
			\subsubsection{\code{for-in} Loops}
			
				\begin{verbatim}
					for x in l
						<BLOCK>
				\end{verbatim}
			
				These loops are similar to \texttt{foreach} constructs in other languages like C\#.
				
				They take a list \code{l} and then iterate over all elements of the list, calling them \code{x}. These variables \code{x} are, again, immutable. The list expression is also only evaluated before the first iteration.
				
				Consider the following example and its output:
				
				\begin{lstlisting}
for val in [1,2,17,-9]
	IO.print_int(val)
				\end{lstlisting}
				
				\begin{verbatim}
					1
					2
					17
					-9
				\end{verbatim}
				
			\subsubsection{\code{break} and \code{continue}}
			
				It is possible to steer the flow of the program by either exiting the current loop using \code{break} or skipping the rest of the loop body using \code{continue}. If \code{continue} is used, the loop condition is evaluated again after potentially updating some loop variables (which is the case in a \code{for} or \code{for-in} loop).
				
				Consider the following example:
				
				\begin{lstlisting}
for i := 1 ... 10
	printf("Loop Iteration {0}\n", i)
	if i > 7
		break
	elif i > 5
		continue
	else
		printf("Value: {0}\n", 2 ** i)
				\end{lstlisting}
				
				This code will produce the following output:
				
				\begin{verbatim}
					Loop Iteration 1
					Value: 2
					Loop Iteration 2
					Value: 4
					Loop Iteration 3
					Value: 8
					Loop Iteration 4
					Value: 16
					Loop Iteration 5
					Value: 32
					Loop Iteration 6
					Loop Iteration 7
				\end{verbatim}
		
		\subsection{Functions}
		
			\subsubsection{Function Definitions}
			
				Functions are defined in global scope using the \code{fn} keyword. They are immutable.
				
				Their definition uses a name, a list of typed parameters and a return type, followed by a function body.
				
				If a function has a return type, it must contain at least one \code{return} statement, and at least one \code{return} statement must be reached by every possible (terminating) flow of execution -- otherwise, the compiler will return with an error.
				
				The following example function computes the scalar product of two real valued vectors:
				
				\begin{lstlisting}
fn scalar_prod (a : [flt], b : [flt]) -> flt
	assert a.length = b.length
	mut res:flt := 0
	for i := 0 ..| a.length
		res := res + a[i] * b[i]
	return res
				\end{lstlisting}
				
			\subsubsection{Function Calls}
			
				Functions can be called either as expression statements (the function call as a statement), or as part of an expression -- provided the function is of type non-\code{void}.
				
				Consider the following example:
				
				\begin{lstlisting}
let x := scalar_prod ([1,2,3], [1,2,3])
IO.print_int (x)
				\end{lstlisting}
				
				The first function call is used in an expression. It returns \texttt{14} according to the function definition in the code example above. The second function call (to \code{IO.print_int}) results in the value of \code{x} being printed to the console.
				
			\subsubsection{Partial Function Application}
			
				Functions can be partially applied (i.e. passing not all arguments to the function to create a new function). This new functor can then be used as a reference object, and it can be called.
				
				Consider the following function definition:
				
				\begin{lstlisting}
fn add (x:int, y:int, z:int) -> int
	return x + y + z
				\end{lstlisting}
				
				Now, this function can be called (for example \code{add(2,3,4) ==> 9}), but not all arguments can be passed to it: \code{add(1,2,_)} creates a new function which takes one integer and returns a new integer. The following code shows this in more detail:
				
				\begin{lstlisting}
let f1 := add(1,2,_)
IO.print_int(f1(3))    # f1(3) === add(1,2,3)

let f2 := add(_,6,_)
IO.print_int(f2(1,-9)) # f2(1,-9) === add(1,6,-9)

let f3 := f2(_,-5)
IO.print_int(f3(0))    # f3(0) === f2(0,-5) === add(0,6,-5)
				\end{lstlisting}
		
		\subsection{Strings, Arrays, Range Lists, List Comprehensions}
		
			\subsubsection{Array Literals}
			
				Array literals come in three shapes: \textbf{Value Lists}, \textbf{Range Lists}, and \textbf{List Comprehensions}. They are all enclosed by square brackets \code{[]}.
				
				\subsubsubsection{Value Lists}
				
					Value lists are simply values separated by commas: \code{[1,2,3]} creates an array of type \code{[int]} with three elements: $1$, $2$ and $3$. \code{['a','b','z']} creates a \code{[char]} object with three elements.
					
					In such a value list, the type of the array is the least common supertype in the $\prec$ relation of subtypes. For example, \code{["hi", null of string]} is of type \code{string?} since \code{string?} is both a supertype of \code{string} (corresponding to the string literal element), and of \code{string?} (itself, corresponding to the \code{null} element).
					
				\subsubsubsection{Range Lists}
				
					Range lists can create integer lists in given bounds, using a start and end value expression, linked by a range specifier (\code{...}, \code{..|}, \code{|..}, and \code{|.|}, as in the \code{for} statement).
					
					For example, \code{[1 ..| 10] === [1,2,3,4,5,6,7,8,9]}. Note that range lists can only create integer lists.
					
				\subsubsubsection{List Comprehensions}
				
					List comprehensions are the most involved way of creating arrays. A list comprehension expression has the following grammar:
					
					\begin{verbatim}
						"[" expr : x in expr, ..., z in expr [ : expr ] "]"
					\end{verbatim}
					
					Between the two colons, a number of variables can be defined. They iterate over the lists they are linked to by the \code{in} keyword. The optional expression after the second colon is a condition expression. If it evaluates to \code{true} (given the current variable values), the expression to the left of the list comprehension expression is evaluated and added to the list, the end result being returned.
					
					Consider the following example:
					
					\begin{lstlisting}
let a := [ 2*x + y  :  x in [1,2,3], y in [4,5]  :  x%y = 0 ]
					\end{lstlisting}
					
					In pseudocode, this list expression gets evaluated as follows:
					
					\begin{verbatim}
						res <- []
						for all x in [1,2,3] do
						    for all y in [4,5] do
						        if x%y = 0 then
						            add 2*x+y to res
						return res
					\end{verbatim}
					
					This allows us to create very elegant programs to -- for example -- sort lists, or find prime numbers:
					
					\begin{lstlisting}
fn primes (limit:int) -> [int]
	assert limit > 0
	return [ x : x in [1...limit] : [ y : y in [1...x] : x%y=0 ].length = 2 ]

fn sort (l:[int]) -> [int]
	if l.length <= 1
		return l
	else
		let less := sort([ x : x in l : x < l[0] ])
		let more := sort([ x : x in l : x > l[0] ])
		return less + [l[0]] + more
					\end{lstlisting}
					
					Note that the \code{sort} expression can be written in a single line using the \code{?->:} ternary operator, but for better readability the code was broken up into multiple lines.
		
		\subsection{Standard Library, \code{sprintf} and \code{printf}}
		
			The standard library is a series of functions and values that are automatically included when a Dromedar program is compiled. It is explained in more detail in later sections.
			
			One specialty of Dromedar is its use of \textbf{native types}: They describe \textit{blackbox objects} which are used by standard library functions. They cannot be ``opened'' by Dromedar programs themselves and must be operated on using native functions. They are used e.g. by the \code{Regex} module of the standard library, where the type \code{Regex.R} corresponds to a finite automaton used for regular expression evaluation.
			
			However, the entirety of the \code{Regex} module is coded in C++ using the \texttt{<regex>} module of C++'s standard library, and \code{Regex.R} corresponds to \texttt{std::regex*}. The \code{Regex} module allows the Dromedar program to hold these automaton pointers in order to pass them to functions and in order to avoid having to recompile a regular expression every time a match is looked for.
			
			The following example of regular expressions shows the use of blackbox native types:
			
			\begin{lstlisting}
let r := Regex.compile("\\d+")
denull r := r
	let matches := Regex.all_matches(r, "123 45.67")
	printf("{0}\n", matches)
			\end{lstlisting}
			
			Since \code{Regex.compile} returns an object of type \code{Regex.R?}, a checked cast must be made first. The output generated by that above code snipped is:
			
			\begin{verbatim}
				[123,45,67]
			\end{verbatim}
		
		\subsection{Garbage Collection}
		
			Reference objects in Dromedar programs are linked to its garbage collector. It mixes the reference counting and mark-sweep approaches for a very simple design -- the actual implementation of the garbage collector requires less than 50 lines of code -- with the capability to collect any structures, even circular ones\footnote{Classical reference counting GC algorithms typically have issues with circular structures}.
		
		\subsection{Compiling Multiple Files, Modules}
		
			One can compile multiple Dromedar source files at the same time by adding them all to the compiler command. Modules separate programs into logically connected chunks. Modules have a depth of 1 -- there are no nested modules.
			
			Modules are declared using the \code{module} keyword. Every file is automatically in a module with its own filename as the module name (stopping at the first whitespace character, and excluding the \texttt{.drm} file extenstion). This logically separates multiple files compiled together.
			
			The following two files define functions which mutually recursively call one another:
			
			\begin{lstlisting}
# file A.drm
fn f (x:int) -> int
	if x = 0
		return 0
	return 2 * B.f(x-1)

# file B.drm
fn f (x:int) -> int
	if x = 0
		return 1
	return 3 * A.f(x-1)
			\end{lstlisting}
			
			The standard library is defined in a single file and features multiple modules. The following code snippet shows the separation of modules:
			
			\begin{lstlisting}
# Standard Library
# ...			

module File

native fn readall (string) -> [string]

module Math

native fn sin (flt) -> flt
native fn cos (flt) -> flt
native fn tan (flt) -> flt
native e  : flt
native pi : flt

# ...
			\end{lstlisting}
			
			Note that these functions are all \code{native} -- they aren't implemented in Dromedar, but rather in C/C++.
	
	\section{Typing System}
	
		Dromedar uses a static, strong and sound typing system -- typing errors cannot happen at runtime. It knows primitive and reference types.
		
		\subsection{Primitives}
		
			There are four primitive types:
			
			\begin{itemize}
				\item \code{int} represents 64-bit 2's complement (signed) integers.
				\item \code{flt} represents 64-bit IEEE-754 standard floating point numbers.
				\item \code{char} represents 8-bit UTF-8 characters.
				\item \code{bool} represents a 1-bit value: \code{true} and \code{false}.
			\end{itemize}
		
		\subsection{Reference Types}
		
			Reference types represent data structures that are laid over pointers to objects stored in the heap. References come in two types: Maybe-\code{null} and Definitely-not-\code{null} types. Operations like array subscript access are only possible with non-\code{null} types to ensure \code{null} safety.
			
			With a non-null-type \code{t}, the type \code{t?} represents a reference type that allows \code{null} values. Primitives are non-nullable.
			
			The following are reference types:
			
			\begin{itemize}
				\item \code{string} represents lists of characters.
				\item \code{[t]} represents an array with elements of type \code{t}.
			\end{itemize}
		
			Thus, e.g. \code{[[int]?]} represents a two-dimensional array of integers which is definitely non-\code{null}, whereas its rows may be \code{null}.
		
		\subsection{Mutability}
		
			In general, variables declared with the \code{let} keyword are immutable, whereas \code{mut} declarations create mutable variables.
			
			For references, Dromedar uses a different notion of mutability: Allowing the object to point to new objects is handled with the \code{mut} declaration. However, even immutable objects are allowed to call methods which alter their internal state -- for example changing an array's element.
			
		\subsection{Subtyping}
		
			Generally, variables and objects can be assigned values of \textit{subtypes}. Every type is a subtype of itself, and e.g. \code{t} is a subtype of \code{t?}. Generally, a subtype is a restricted value set of its supertype -- any subtype expression can be assigned to a variable of its supertype.
		
	\section{Expressions}
	
		Because Dromedar has a strong type system, it generally disallows any operations with operands of a non-specified type unless they are explicitly cast to the correct type before. This means that integer and floating point numbers cannot be added, multiplied, etc.
		
		The following table describes precedence and type of all operators:\\
		
		\begin{tabular}{l|l|c|l|l}
			\textbf{Operator} & \textbf{Name} & \textbf{Prec.} & \textbf{Assoc.} & \textbf{Types}\\
			\midrule
			\code{-} & Unary Negation & 100 & non-assoc. & \code{int -> int}\\
				&&&& \code{flt -> flt}\\
			\code{!} & Logical Negation &&& \code{bool -> bool}\\
			\midrule
			\code{**} & Exponentiation & 90 & right & \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
				&&&& \code{int,flt -> flt}\\
				&&&& \code{flt,int -> flt}\\
			\midrule
			\code{*} & Multiplication & 80 & left &
					 \code{int,int -> int}\\
				&&&& \code{flt,flt -> flt}\\
				&&&& \code{int,flt -> flt}\\
				&&&& \code{flt,int -> flt}\\
			\midrule
			\code{+} & String Addition & 70 & left &
				\code{string,string -> string}\\
			\midrule
			\code{+},\code{-} & Addition & 70 & left &
					 \code{int,int -> int}\\
				& Subtraction &&&
					 \code{flt,flt -> flt}\\
				&&&& \code{int,flt -> flt}\\
				&&&& \code{flt,int -> flt}\\
				&&&& \code{char,int -> char}\\
				&&&& \code{int,char -> char}\\
			\midrule
			\code{<<},\code{>>},\code{>>>} & Left Shift & 60 & left & \code{int,int -> int}\\
			& Logical Right Shift &&& \\
			& Arithmetic Right Shift &&& \\
			\midrule
			\code{\&} & Bitwise And & 60 & left & \code{int,int -> int}\\
			\midrule
			\code{\^} & Bitwise Xor & 50 & left & \code{int,int -> int}\\
			\midrule
			\code{|} & Bitwise Or & 40 & left & \code{int,int -> int}\\
			\midrule
			\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=} & Comparison & 30 & non-assoc. & \code{[int/flt] -> bool} \\
				&&&& \code{[char] -> bool}\\
			\midrule
			\code{=},\code{!=},\code{>},\code{<},\code{>=},\code{<=} & Structural Comparison & 30 & non-assoc. & \code{[string]->bool} \\
			\midrule
			\code{==},\code{!==} & Reference Comparison & 30 & non-assoc. & \code{[rt1...rtn]->bool}\\
			\midrule
			\code{\&\&} & Logical And & 20 & left & \code{bool,bool -> bool}\\
			\midrule
			\code{||} & Logical Or & 10 & left & \code{bool,bool -> bool}\\
			\midrule
			\code{?->:} & Ternary Operator & 0 & non-assoc. & \code{bool,t1,t2 -> t}
		\end{tabular}\\
	
		Consider the following example:
		
		The expression \code{1+18-18+'a'} is well-typed (of type \code{char}) and gets parsed as \code{((1+18)-18)+'a'} and evaluated to \code{'b'}. \code{10 - 0.0} on the other hand is not well-typed as \code{-} cannot take an \code{int} and a \code{flt} operand as arguments.
		
		Comparison operators work differently to other (binary) operators: Instead of comparing just two expressions, Dromedar allows chaining expressions to create one final boolean value: For example, \code{1 < 2 != 5 >= 5} holds because every single sub-expression (\code{1 < 2}, \code{2 != 5} and \code{5 >= 5}) holds. Every expression is only evaluated once for its side-effect.
		
		Thus, \code{A op B op C} is not necessarily semantically equivalent to \code{A op B \&\& B op C}.
		
		The ternary operator takes three expressions: \code{? cond -> e1 : e2}. If \code{cond} evaluates to \code{true}, \code{e1} is returned, otherwise \code{e2}. \code{e1} and \code{e2} must have a common supertype, which is returned by the expression.
		
	\section{Handling Whitespace}
	
		In order to keep the code simple and easy to look at, Dromedar uses significant whitespace: Blocks of code (such as bodies of \code{if}) statements, are denoted by adding a level of indentation.
		
		Every line is either empty (this includes lines containing only comments), or it contains code. 
		
		If a line contains code, the level of its indentation is determined by its relationship to the previous line and its environment:
		
		Two neighboring lines of code within the same block of code must have exactly matching whitespace characters before their respective code starts. If a following line has a deeper level of indentation, it must match the whitespace characters of the previous line and then add a number of additional whitespace characters (space(s) and/or tab(s)).
		
		A line of code can only have a deeper indentation level of one step compared to the previous line. The first line of code is always a global instruction and as such has the lowest level of indentation. If it is indented, this level of indentation corresponds to a baseline indentation that every line of code must share.
		
		Consider this valid example:
		
		\begin{lstlisting}
  global x := 3 		# baseline indentation of two spaces
						# empty line -> indentation doesn't matter
  fn main : args:[string] -> int
  			Stdio.println("Hello, World!")	# deeper indentation level
  			return 0						# same indentation level
		\end{lstlisting}
		
		Blocks with the same level of indentation can have different indentation strings, but they must still match their environments, as follows:
		
		\begin{lstlisting}
		if <condition>
				BLOCK A
		else
		  BLOCK B
		\end{lstlisting}
		
		The two blocks have a different indentation level, but from context it is still clear that \code{BLOCK A} is a sub-block of the \code{if}-statement, whereas \code{BLOCK B} belongs to the \code{else}-statement.
		
		\subsection{Multiline Expressions}
		
			Some instructions are too long to write on a single line -- e.g. complicated \code{if} conditions. In that case, it is possible to write such instructions or expressions on multiple lines, provided that the indentation levels of the subsequent lines are deeper than that of the first line of the instruction.
			
			The file \texttt{Droml/droml.config} specifies the size of a tab character in terms of spaces in order to allow mixing tabs and spaces.
			
			The following is an example of such multiline instructions:
			
			\begin{lstlisting}
fn main -> void
	let p :=
		[ x
		: x in [1...100]
		: [ y : y in [1...x] : x%y = 0 ].length = 2 ]
	printf("{0}\n", p)
			\end{lstlisting}
			
			This program computes the prime numbers from \code{0} to \code{100} using list comprehensions, where the list expression is divided into three separate lines.
			
		\subsection{Multiple Statements on a Single Line}
		
			While some instructions are long enough to require multiple lines to remain readable, some instructions are so short (such as simple assignments), that it enhances the readability of a chunk of code to put multiple statements on a single line. This is enabled by separating instructions with an optional Semicolon \code{;}, e.g. as follows:
			
			\begin{lstlisting}
fn main -> void
	printf("a\n"); printf("b\n") # the semicolon separates the two commands
	
	if true
		printf("c\n")  # if a line break follows, a semicolon is optional
	else
		printf("d\n"); # this semicolon can be omitted
			\end{lstlisting}
		
	\section{Buildup of a Program}
	
		A program consists of a series of global statements -- global variable declarations and function definitions.
		
		\subsection{Global Declarations}
		
			Global variables are all assigned a value at the point of their declaration. This value is evaluated statically -- declaration expressions can only contain literals and global variables that were already declared previously.
			
			Functions are also declared globally. They can call each other and themselves recursively within their respective function bodies.
			
		\subsection{Standard Library}
		
			The Dromedar standard library includes the following functions and objects:
			
			\subsubsection{\code{Str}: String Operations}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{Str.of_int} & \code{int -> string} & transforms an integer into a string \\
					\code{Str.of_flt} & \code{flt -> string} & transforms a decimal number into a string
				\end{longtable}
			
			\subsubsection{\code{IO}: Standard I/O Operations}
			
				Printing operations are always preceded by the \code{IO} library name.
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{IO.print_str} & \code{string -> void} & prints a string to the console\\
					\code{IO.print_int} & \code{int -> void} & prints an integer to the console\\
					\code{IO.print_flt} & \code{flt -> void} & prints a real number to the console\\
					\code{IO.print_char} & \code{char -> void} & prints a character to the console\\
					\code{IO.print_bool} & \code{bool -> void} & prints \code{"true"} or \code{"false"} to the console
				\end{longtable}
			
			\subsubsection{\code{Util}: Miscellaneous Utility Functions}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{Util.randint} & \code{() -> int} & random integer from $-2^63$ to $2^63-1$ \\
					\code{Util.randflt} & \code{() -> flt} & random floating point number in $[0,1)$
				\end{longtable}
			
			\subsubsection{\code{File}: File I/O}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{File.readall} & \code{string -> [string]} & returns all lines from the file with the given input name
				\end{longtable}
			
			\subsubsection{\code{Math} : Mathematical Operations}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{Math.sin} & \code{flt -> flt} & sine function \\
					\code{Math.cos} & \code{flt -> flt} & cosine function \\
					\code{Math.tan} & \code{flt -> flt} & tangent function \\
					\code{Math.e} & \code{flt} & Euler's constant \\
					\code{Math.pi} & \code{flt} & $\pi$ constant
				\end{longtable}
			
			\subsubsection{\code{Regex}: Regular Expressions}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{<type>} & \code{R} & blackbox type that represents a regex automaton \\
					\code{compile} & \code{string -> R?} & returns \code{null} if the compilation to a regex automaton fails \\
					\code{matches} & \code{(R,string) -> bool} & finds whether a partial match in the given string exists \\
					\code{first_match} & \code{(R,string) -> string?} & returns the first regex match (if it exists, else \code{null}) \\
					\code{all_matches} & \code{(R,string) -> [string]} & finds all matches
				\end{longtable}
			
			\subsubsection{\code{Sys} : System Calls, etc.}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{cmd} & \code{string -> int} & executes a shell command \\
					\code{fork} & \code{() -> int} & executes the \code{fork()} \textsc{Unix} system call
				\end{longtable}
			
			\subsubsection{\code{Time} : Date and Time Utilities}
			
				\begin{longtable}{l|l|l}
					\textbf{Name} & \textbf{Type} & \textbf{Effect} \\
					\midrule
					\code{<type>} & \code{P} & blackbox type representing a point in time \\
					\code{<type>} & \code{D} & blackbox type representing a duration \\
					\code{clock} & \code{() -> int} & the number of clock ticks since the start of the program \\
					\code{time} & \code{() -> int} & returns the \textsc{Unix} time \\
					\code{now} & \code{() -> P} & the time point representing the point when \code{now()} was called \\
					\code{dt} & \code{(P,P) -> D} & calculates the time difference between the first and the second time point \\
					\code{s} & \code{D -> int} & duration in seconds \\
					\code{ms} & \code{D -> int} & duration in milliseconds \\
					\code{us} & \code{D -> int} & duration in microseconds
				\end{longtable}
		
	\section{Garbage Collection}
	
		Dromedar uses an algorithm that combines the mark/sweep and reference counting approaches. It is a \textit{precise} garbage collection algorithm, meaning that it is capable of collecting all non-reachable objects and it will only attempt to GC exactly these (as opposed to conservative GC algorithms like the Boehm-Demers-Weiser garbage collector for C/C++).
		
		Internally, each reference object is stored in a central garbage collection table that counts the numbers of program references that can reach a program, as well as the set of its children.
		
		When a garbage collection run is triggered, the collector will free all objects that are not reachable. An object is deemed \textbf{reachable} if either its count of program references is nonzero, or if it is the child of a reachable object.
		
	\section{Formal Typing Rules}
	
		A typing rule takes the following shape: $$ \drmrule{\mathrm{Hypotheses}}{S,\dots}{type}{\mc{grammar spec}}{name} $$
		
		Here, $S$ represents a list of stacks (resp. a stack) of symbol definitions: $S \in (\mathsf{id} \times \mathsf{type} \times \{c,m\})^n$ for some block depth $n$ at any given point. In global context, $S$ has only one layer. $\mathsf{id}$ corresponds to the set of names that variables can have (related to the Lexer symbol \texttt{\%Identifier}), $\mathsf{type}$ to the set of types in a given program (related to the Parser symbol \texttt{Type}), and $\{c,m\}$ to the mutability of the object: $c$ represents an immutable value (as declared by \code{let}), and $m$ a mutable one (declared by \code{mut}).
		
		Writing $S$ in a proof rule enables access to functions and variables within the same module \code{M}, whereas $S_{\mc{N}}$ corresponds to the context from module \code{N}.
		
		The symbol $\in$ is defined as follows: $s\in S \Leftrightarrow \textnormal{$s$ is contained in \textit{any} layer of $S$}$, whereas $\in_0$ is true only if the symbol is at the top level of the symbol stack (i.e. defined in the same block). The operator $\cup$ on $S$ adds another binding to the top layer of the stack, whereas $\sqcup$ adds another layer to the stack.
		
		These typing rules deal with templates in an informal way: There are formal rules for template type matching, but the information about detemplated functions is not carried around through the rules in order to reduce the size of the rules and improve their readability.
		
		Instead, they are carried around in two global symbols: $F \in \mathsf{id} \times \mathsf{type}$ refers to a set of generic functions. For every application, all templated types must be resolved at compile-time (this includes partial application!). The symbol $R \in \mathsf{id} \mathsf{type}$ refers to a set of resolved generic functions. These are then appended to the handwritten program. This may perhaps require several steps of template resolution, and template resolution may not have a fixpoint. In that case, the compiler will throw an error.
		
		The following is an example of misuse of generics such that no program can be built:
		
		\begin{lstlisting}
fn f (x : <a>) -> <a>
	return f([x])[0] # resolves f's <a> to [<a>] ->
					 # infinite recursive loop in template resolution

fn main -> void
	IO.print_int(f(0))
		\end{lstlisting}
		
		The following are the typing rules for Dromedar programs:
		
		\subsection{Subtyping Rules}
		
			\subsubsection{Cross-Typing}
			
				Cross types are types which aren't related by the subtype relation $\preceq$ but still allow for some typesafe interaction -- e.g. by assigning variables of one type to variables of another.
				
				The crosstype relation, denoted by the $\asymp$ operator, commutes.
				\begin{align*}
					\drmrule{}{}{T}{\mc{int} \asymp \mc{flt}}{CrossTyIntFlt},\ \ 
					\drmrule{}{}{T}{\mc{flt} \asymp \mc{int}}{CrossTyFltInt}
				\end{align*}
		
			\subsubsection{Trivial Rule}
			
				\begin{align*}
					\drmrule{}{}{T}{\mc{t} \preceq \mc{t}}{SubTyTrivial}
				\end{align*}
				
			\subsubsection{References}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{t1} \preceq \mc{t2}}{}{T}{\mc{t1} \preceq \mc{t2?}}{SubTyRefs},\ \ 
					\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{t2}}{}{T}{\mc{t1?} \preceq \mc{t2?}}{SubTyRefs}
				\end{align*}
				
			\subsubsection{Arrays}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{t2}}{}{T}{\mc{[t1]}\preceq\mc{[t2]}}{SubTyFuns}
				\end{align*}
		
			\subsubsection{Functions}
			
				\begin{align*}
					\drmrule{\ruleapp{T}\mc{u1}\preceq\mc{t1},\ \dots,\ \ruleapp{T}\mc{un}\preceq\mc{tn}\ \ \ruleapp{T}\mc{rt}\preceq\mc{ru}}{}{T}{\mc{(t1,...,tn)->rt} \preceq \mc{(u1,...,un)->ru}}{SubTyFuncs}
				\end{align*}
				
			\subsubsection{Subtypes and Supertypes}
			
				The functions $\mathsf{subtys}$ and $\mathsf{suptys}$ of $\mathsf{types}\to\mathcal{P}(\mathsf{types})$ compute the sub- and supertype set of the input type, respectively.
				
				They are used -- among others -- in the \textsc{ExpLitArr} rule.
				
				\begin{align*}
					\mathsf{subtys} &:=
						\left\{
							\begin{array}{lll}
								\mc{int} & \mapsto & \{\mc{int}\}\\
								\mc{flt} & \mapsto & \{\mc{flt}\}\\
								\mc{char} & \mapsto & \{\mc{char}\}\\
								\mc{bool} & \mapsto & \{\mc{bool}\}\\
								\mc{string} & \mapsto & \{\mc{string}\}\\
								\mc{M.Id} & \mapsto & \{\mc{M.Id}\}\\
								\mc{t?} & \mapsto & \{\mc{u},\mc{u?} \;\mid\; \mc{u}\in\mathsf{subtys}(\mc{t})\}\\
								\mc{[t]} & \mapsto & \{\mc{[u]} \;\mid\; \mc{u}\in\mathsf{subtys}(\mc{t})\}\\
								\mc{(t1...tn)->rt} & \mapsto &
									\{\mc{(u1...un)->st} \;\mid\; \mc{u1...un}\in\mathsf{suptys}(\mc{t1...tn}),\mc{st}\in\mathsf{subtys}(\mc{rt})\}
							\end{array}
						\right.\\
					\mathsf{suptys} &:=
						\left\{
							\begin{array}{lll}
								\mc{int} & \mapsto & \{\mc{int}\}\\
								\mc{flt} & \mapsto & \{\mc{flt}\}\\
								\mc{char} & \mapsto & \{\mc{char}\}\\
								\mc{bool} & \mapsto & \{\mc{bool}\}\\
								\mc{string} & \mapsto & \{\mc{string},\mc{string?}\}\\
								\mc{M.Id} & \mapsto & \{\mc{M.Id},\mc{M.Id?}\}\\
								\mc{t?} & \mapsto & \{\mc{u?} \;\mid\; \mc{u}\in\mathsf{suptys}(\mc{t})\}\\
								\mc{[t]} & \mapsto & \{\mc{[u]}, \mc{[u]?} \;\mid\; \mc{u}\in\mathsf{suptys}(\mc{t})\}\\
								\mc{(t1...tn)->rt} & \mapsto &
									\left[
									\begin{array}{l}
										\{\mc{(u1...un)->st},\mc{((u1...un)->st)?} \\\ \ \;\mid\; \mc{u1...un}\in\mathsf{subtys}(\mc{t1...tn}),\mc{st}\in\mathsf{suptys}(\mc{rt})\}
									\end{array}
									\right.
							\end{array}
						\right.
				\end{align*}
				
		\subsection{Declared Types}
			
				\begin{align*}
					\drmrule{}{T}{D}{\mc{int}}{TDInt},\ \ \drmrule{}{T}{D}{\mc{flt}}{TDFlt},\ \ 
					\drmrule{}{T}{D}{\mc{char}}{TDChar},\ \ \drmrule{}{T}{D}{\mc{bool}}{TDBool}\\
					\drmrule{T\ruleapp{D}\mc{t}}{T}{D}{\mc{[t]}}{TDArray},\ \ \drmrule{}{T}{D}{\mc{string}}{TDString},\ \ 
					\drmrule{\mc{id}\in T}{T}{D}{\mc{tid}}{TDNative}\\
					\drmrule{T\ruleapp{D}\mc{t1},\ \dots,\ T\ruleapp{D}\mc{tn}\ \ T\ruleapp{D}\mc{rt}}{T}{D}{\mc{(t1,...,tn)->rt}}{TDFunc}
				\end{align*}
		
		\subsection{Builtin Operators}
		
			Many builtin operators are overloaded, providing functionality for multiple input types.
			
			\subsubsection{Unary Operators}
			
				\subsubsubsection{Arithmetic Negation}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{-} :: \mc{int->int}}{TyUopNegInt},\ \ 
						\drmrule{}{}{O}{\mc{-} :: \mc{flt->flt}}{TyUopNegInt}
					\end{align*}
				
				\subsubsubsection{Logical Negation}

					\begin{align*}
						\drmrule{}{}{O}{\mc{!} :: \mc{bool->bool}}{TyUopNot}
					\end{align*}
			
			\subsubsection{Binary Operators}
			
				\subsubsubsection{Power}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{**} :: \mc{(int,int)->int}}{TyBopPowInt},\ \ &
						\drmrule{}{}{O}{\mc{**} :: \mc{(flt,flt)->flt}}{TyBopPowFlt}\\
						\drmrule{}{}{O}{\mc{**} :: \mc{(int,flt)->flt}}{TyBopPowIntFlt},\ \ &
						\drmrule{}{}{O}{\mc{**} :: \mc{(flt,int)->flt}}{TybopPowFltInt}
					\end{align*}
				
				\subsubsubsection{Multiplication, Division, Modulo}
				
					\begin{align*}
						\drmrule{}{}{O}{\mc{*} :: \mc{(int,int)->int}}{TyBopMulInt},\ \ &
						\drmrule{}{}{O}{\mc{*} :: \mc{(flt,flt)->flt}}{TyBopMulInt}\\
						\drmrule{}{}{O}{\mc{*} :: \mc{(int,flt)->flt}}{TyBopMulIntFlt},\ \ &
						\drmrule{}{}{O}{\mc{*} :: \mc{(flt,int)->flt}}{TyBopMulFltInt}
					\end{align*}\begin{align*}
						\drmrule{}{}{O}{\mc{*} :: \mc{(int,string)->string}}{TyBopMulIntStr},\ \ &
						\drmrule{}{}{O}{\mc{*} :: \mc{(string,int)->string}}{TyBopMulStrInt}
					\end{align*}
					
					\begin{align*}
						\drmrule{}{}{O}{\mc{/} :: \mc{(int,int)->int}}{TyBopDivInt},\ \ &
						\drmrule{}{}{O}{\mc{/} :: \mc{(flt,flt)->flt}}{TyBopDivInt}\\
						\drmrule{}{}{O}{\mc{/} :: \mc{(int,flt)->flt}}{TyBopDivIntFlt},\ \ &
						\drmrule{}{}{O}{\mc{/} :: \mc{(flt,int)->flt}}{TybopDivFltInt}
					\end{align*}
					
					\begin{align*}
						\drmrule{}{}{O}{\mc{\%} :: \mc{(int,int)->int}}{TyBopModInt}
					\end{align*}
				
				\subsubsubsection{Addition and Subtraction}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,int)->int}}{TyBopAddInt},\ \ &
								\drmrule{}{}{O}{\mc{+} :: \mc{(flt,flt)->flt}}{TyBopAddFlt},\\
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,flt)->flt}}{TyBopAddIntFlt},\ \ & 
								\drmrule{}{}{O}{\mc{+} :: \mc{(flt,int)->flt}}{TyBopAddFltInt}\\
								\drmrule{}{}{O}{\mc{+} :: \mc{(int,char)->char}}{TyBopAddCharR},\ \ &
								\drmrule{}{}{O}{\mc{+} :: \mc{(char,int)->char}}{TyBopAddCharL}
							\end{align*}\begin{align*}
								\drmrule{}{}{O}{\mc{+} :: \mc{(string,string)->string}}{TyBopAddString}
							\end{align*}\begin{align*}
								\drmrule{\mc{t}=\min_\preceq(\mathsf{suptys}(\mc{t1})\cap\mathsf{suptys}(\mc{t2}))}{}{O}{\mc{+} :: \mc{([t1],[t2])->[t]}}{TyBopAddArr}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,int)->int}}{TyBopSubInt},\ \ &
								\drmrule{}{}{O}{\mc{-} :: \mc{(flt,flt)->flt}}{TyBopSubFlt},\\
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,flt)->flt}}{TyBopSubIntFlt},\ \ & 
								\drmrule{}{}{O}{\mc{-} :: \mc{(flt,int)->flt}}{TBbopSubFltInt}\\
								\drmrule{}{}{O}{\mc{-} :: \mc{(int,char)->char}}{TyBopSubCharR},\ \ &
								\drmrule{}{}{O}{\mc{-} :: \mc{(char,int)->char}}{TyBopSubCharL}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Shift Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{<<} :: \mc{(int,int)->int}}{TyBopLShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{>>} :: \mc{(int,int)->int}}{TyBopBitRShift}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{>>>} :: \mc{(int,int)->int}}{TyBopBitAShift}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Bitwise Operators}
				
					\begin{itemize}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{\&} :: \mc{(int,int)->int}}{TyBopBitAnd}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{^} :: \mc{(int,int)->int}}{TyBopXor}
							\end{align*}
						\item
							\begin{align*}
								\drmrule{}{}{O}{\mc{|} :: \mc{(int,int)->int}}{TyBopBitOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Logical Operators}
				
					\begin{itemize}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{\&\&} :: \mc{(bool,bool)->bool}}{TyBopLogAnd}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{\^\^} :: \mc{(bool,bool)->bool}}{TyBopLogXor}
							\end{align*}
						\item 
							\begin{align*}
								\drmrule{}{}{O}{\mc{||} :: \mc{(bool,bool)->bool}}{TyBopLogOr}
							\end{align*}
					\end{itemize}
				
				\subsubsubsection{Comparison Operators}
				
					\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(int,...,int)->bool}}{TyCmpListInt}
					\end{align*}\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(flt,...,flt)->bool}}{TyCmpListFlt}
					\end{align*}\begin{align*}
						\drmrule{}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(char,...,char)->bool}}{TyCmpListChar}
					\end{align*}\begin{align*}
						\drmrule{\ruleapp{T}\mc{t1}\preceq\mc{string},\ \dots,\ \ruleapp{T}\mc{tn}\preceq\mc{string}}{}{O}{\{\mc{=},\mc{!=},\mc{>},\mc{<},\mc{>=},\mc{<=}\} :: \mc{(t1,...,tn)->bool}}{TyCmpListRefStr}
					\end{align*}\begin{align*}
						\drmrule{\ruleapp{T}\mc{t1}\preceq/\succeq\mc{t2},\ \dots,\ \ruleapp{T}\mc{t(n-1)}\preceq/\succeq\mc{tn}\ \ \mc{t1},\dots,\mc{tn}\textnormal{ reference types}}{}{O}{\{\mc{==},\mc{!==}\} :: \mc{(t1,...,tn)->bool}}{TyCmpListRefVal}
					\end{align*}
					
					
		\subsection{Expressions}
		
			\subsubsection{Subtyping Expression Rule}
			
				To reduce proof rule size, define the following rules:
				
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1}\ \ \ruleapp{T}\mc{t1}\preceq\mc{t}}{S}{ET}{\mc{exp} \trianglelefteq \mc{t}}{ExpSubLocal},\ \ &
					\drmrule{S\ruleapp{G}\mc{exp}::\mc{t1}\ \ \ruleapp{T}\mc{t1}\preceq\mc{t}}{S}{GT}{\mc{exp} \trianglelefteq \mc{t}}{ExpSubGlobal}\\
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1},\ \ \ruleapp{T}\mc{t1}\asymp\mc{t}}{S}{ET}{\mc{exp}\bowtie\mc{t}}{ExpCrossLocal}\ \ &
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1},\ \
					\ruleapp{T}\mc{t1}\asymp\mc{t}}{S}{GT}{\mc{exp}\bowtie\mc{t}}{ExpCrossGlobal}
				\end{align*}
		
			\subsubsection{Assignability}
			
				The rule $\ruleapp{A}$ defines when an expression can be assigned a value; $\ruleapp{AC}$ is equivalent to $\ruleapp{A}$ -- except that it also allows immutable objects whose children (e.g. array elements) can still be modified.
				
				\begin{align*}
					\drmrule{(\mc{id},\_,m)\in S}{S}{A}{\mc{id}}{ExpAssnId}\ \ 
					\drmrule{S\ruleapp{AC}\mc{e1}}{S}{A}{\mc{e1[e2]}}{ExpAssnSub}
				\end{align*}
				
				\begin{align*}
					\drmrule{(\mc{id},\_,\_)\in S}{S}{AC}{\mc{id}}{ExpAssnId'}\ \ 
					\drmrule{S\ruleapp{AC}\mc{e1}}{S}{AC}{\mc{e1[e2]}}{ExpAssnSub'}
				\end{align*}
				
			\subsubsection{Global Expressions}
			
				The rule $\vdash_G$ describes global expressions, which are restricted in a way that they can be computed at compile time. Global variables are also strictly non-\code{null}.
				
				The following copied rules use $\vdash_G$ instead of $\vdash_E$
				
				\subsubsubsection{Literals}
				
					\begin{itemize}
						\item \textsc{GExpLitInt} $:=$ \textsc{ExpLitInt}
						\item \textsc{GExpLitFlt} $:=$ \textsc{ExpLitFlt}
						\item \textsc{GExpLitChar} $:=$ \textsc{ExpLitChar}
						\item \textsc{GExpLitBool} $:=$ \textsc{ExpLitBool}
					\end{itemize}
				
				\subsubsubsection{Other Rules}
				
					\begin{itemize}
						\item \textsc{GExpId} $:=$ \textsc{ExpId}
						\item \textsc{GExpUop} $:=$ \textsc{ExpUop}
						\item \textsc{GExpBop} $:=$ \textsc{ExpBop}
						\item \textsc{GExpCmpList} $:=$ \textsc{ExpCmpList}
					\end{itemize}
				
					Note that global variable declarations cannot feature function calls or \code{null} declarations.
		
			\subsubsection{Literals}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{}{S}{E}{n :: \mc{int}}{ExpLitInt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{S}{E}{f :: \mc{flt}}{ExpLitFlt}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{S}{E}{c :: \mc{char}}{ExpLitChar}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{S}{E}{\mc{true} :: \mc{bool}}{ExpLitBoolTrue},\ \ 
							\drmrule{}{S}{E}{\mc{false} :: \mc{bool}}{ExpLitBoolFalse}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{}{S}{E}{s :: \mc{string}}{ExpLitString}
						\end{align*}
					\item
						In arrays, the typechecker looks for the common subtypes of all array literal elements and looks for the one type \code{t} that is a supertype of all elements and which is a subtype of all other such subtypes (the minimum of the subtypes given the $\preceq$ relation on types).
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{e1}::\mc{t1},\ \dots,\ S\ruleapp{E}\mc{en}::\mc{tn}\ \ \mc{t} = \min_\preceq (\bigcap_{\mc{i}=\mc{1}}^{\mc{n}}\mathsf{suptys}(\mc{ti}))}{S}{E}{\mc{[e1,...,en]} :: \mc{[t]}}{ExpLitArr}
						\end{align*}
						
						Because the graph connecting types and subtypes is a forest of trees, if the intersection of supertypes is nonempty there is a unique solution \code{t}.
				\end{itemize}
			
			\subsubsection{Range List}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e1}::\mc{int}\ \ S\ruleapp{E}\mc{e2}::\mc{int}}{S}{E}{\mc{[e1 \%RangeSpecifier e2]} :: \mc{[int]}}{ExpRangeArrInt},\\
					\drmrule{S\ruleapp{E}\mc{c1}::\mc{char}\ \ S\ruleapp{E}\mc{c2}::\mc{char}}{S}{E}{\mc{[c1 \%RangeSpecifier c2]} :: \mc{[char]}}{ExpRangeArrChar}
				\end{align*}
				
			\subsubsection{List Comprehension}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{l1}::\mc{[t1]},S_1:=S\cup\{(\mc{l1},\mc{t1},c)\}\ruleapp{E}\mc{l2}::\mc{[t2]},\ \dots,\ S_{n-1}\ruleapp{E}\mc{ln}::\mc{[tn]}\ \ S_n\ruleapp{E}(\mc{e},\mc{c})::(\mc{t},\mc{bool})}{S}{E}{\mc{[e : x1 in l1, ..., xn in ln : c]}::\mc{[t]}}{ExpLC}
				\end{align*}
			
			\subsubsection{Null}
			
				\begin{align*}
					\drmrule{\textnormal{\code{t} is a non-null ref. type}}{S}{E}{\mc{null of t} :: \mc{t?}}{ExpNull}
				\end{align*}
				
			\subsubsection{Dangerous Dereference}
			
				\begin{align*}
					\drmrule{S\ruleapp{E} \mc{exp} :: \mc{t?}}{S}{E}{\mc{assert exp} :: \mc{t}}{ExpDeref}
				\end{align*}
				
			\subsubsection{Ternary Operator}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c}::\mc{bool}\ \ S\ruleapp{E}\mc{e1}::\mc{t1},\ S\ruleapp{E}\mc{e2}::\mc{t2}\ \ \mc{t}=\min_\preceq(\mathsf{suptys}(\mc{t1})\cap\mathsf{suptys}(\mc{t2}))}{S}{E}{\mc{?c -> e1 : e2} :: \mc{t}}{ExpTern}
				\end{align*}
			
			\subsubsection{Identifiers}
			
				\begin{align*}
					\drmrule{(id,\mc{t},\_)\in S}{S}{E}{\mc{id} :: \mc{t}}{ExpId}
				\end{align*}
			
			\subsubsection{Unary Operations}
			
				Unary and Binary Operations do not need to do subtype checking, as they operate only on primitives.
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t1}\ \ \ruleapp{O}\mc{op}::\mc{t1->t}}{S}{E}{\mc{op exp}::\mc{t}}{ExpUop}
				\end{align*}
			
			\subsubsection{Binary Operations}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e1}::\mc{t1}\ \ S\ruleapp{ET}\mc{e2}::\mc{t2}\ \ \ruleapp{O}\mc{op}::\mc{(t1,t2)->t}}{S}{E}{\mc{e1 op e2} :: \mc{t}}{ExpBop}
				\end{align*}
			
			\subsubsection{Function Calls}
			
				This type rule requires $\mc{rt}\not\equiv\mc{void}$ unless otherwise specified in another rule or if the application of the function is only partial.
				
				For an $n$-tuple $L$ over $U$ and a value $v\in U$, let $(L,v)$ correspond to $(L_1,\dots,L_n,v)\in U^{n+1}$.
			
				\begin{small}
				\begin{align*}
					\drmrule{
						\begin{array}{rl}
							S&\ruleapp{E}\mc{f}::\mc{(t1,...,tn)->rt}\\
							&\mathsf{resolve}(\mc{t1,...,tn};\mathsf{types\ of\ }\mc{e1,...,en})
						\end{array},\ \left\{ 
						\begin{array}{rl}
							S&\ruleapp{ET}\mc{e1}\trianglelefteq\mc{t1}\vee\mc{e1}\bowtie\mc{t1} \leadsto ()=:L_1 \bigvee
								\mc{e1} \equiv \_ \leadsto (\mc{t1})=:L_1,\\
							&\vdots\\
							S&\ruleapp{ET}\mc{en}\trianglelefteq\mc{tn}\vee\mc{en}\bowtie\mc{tn} \leadsto L_{n-1}=:L_n \bigvee
								\mc{e1} \equiv \_ \leadsto (L_{n-1},\mc{tn})=:L_n
						\end{array}\right.}{S}{E}{\mc{f(e1,...,en)}:: \mathbf{if}\ L_n=()\ \mathbf{then}\ \mc{rt} \ \mathbf{else}\ L_n\mc{->rt}}{ExpFunc}
				\end{align*}
				\end{small}
				
			\subsubsection{Template Resolution}
			
				The function $\mathsf{resolve}$ receives a vector of expected and provided types (as used in the rule above). It, quite informally, changes the expected types by matching templates.
				
				\begin{verbatim}
					resolve(t1,...,tn ; p1,...,pn)
					    M := mappings of all template types in t1...tn: [ ty -> unknown ]
					    for all i = 1...n do
					        if p1 exists (for partial f-app) then
					            attempt to match templates such that p1 is a subtype of t1*
					            update M accordingly if it works, otherwise fail
					        else
					            skip
					        end
					    end
					    
					    if function with new types doesn't exist in program
					    	add it to P to be typechecked after replacing all contained generic types
					    	if that fails, fail
					   	else
					   		return
				\end{verbatim}
				
				This (quite informal) algorithm attempts to assign all templated types \code{<id>} real types such that all function arguments match. If this is not possible, a matching cannot be made and the template match fails.
				
				The following example shows an example of template resolution:
				
				\begin{lstlisting}
fn f (e1 : <a>, e2 : <a>) -> <a>
	# do something

...

# [string]?       , [string?]
f(null of [string], [null of string])
				\end{lstlisting}
				
				\code{f} gets passed values of two types: \code{[string]?} and \code{[string?]}. These are not directly related by the subtyping relation $\preceq$. However, they have a common supertype \code{[string?]?}. Because this is the case, \code{<a>} can be set to that type \code{[string?]?}, and the template type matching works.
				
			\subsubsection{\code{sprintf} call}
			
				Because Dromedar is typesafe, a construct like \code{sprintf} is not possible within the standard framework of the language. Instead, it uses the \code{sprintf} keyword that generates a string from the input string and its arguments.
				
				First, define the rule to decide whether an object type is \textit{printable}:
				
				\begin{align*}
					\drmrule{}{}{P}{\mc{int}}{PrtInt},\ \ 
					\drmrule{}{}{P}{\mc{flt}}{PrtFlt},\ \ 
					\drmrule{}{}{P}{\mc{char}}{PrtChar},\ \ 
					\drmrule{}{}{P}{\mc{bool}}{PrtBool},\ \ 
					\drmrule{}{}{P}{\mc{string}}{PrtString}
				\end{align*}\begin{align*}
					\drmrule{\ruleapp{P}\mc{t}}{}{P}{\mc{[t]}}{PrtArr}
				\end{align*}
				
				\begin{align*}
					\drmrule{0\leq\mc{j1}<\mc{n},\ \dots,\ 0\leq\mc{jm}<\mc{n}\ \ S\ruleapp{E}\mc{e1}::\mc{t1},\ \dots,\ S\ruleapp{E}\mc{en}::\mc{tn}\ \ \ruleapp{P}\mc{t1},\ \dots,\ \ruleapp{P}\mc{tn}}{S}{E}{\mc{sprintf("...\{j1\}...\{jm\}...", e1,...,en)} :: \mc{string}}{ExpSprintf}
				\end{align*}
				
			\subsubsection{Subscript Access}
			
				\begin{itemize}
					\item
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{s}::\mc{string}\ \ S\ruleapp{E}\mc{i}::\mc{int}}{S}{E}{\mc{s[i]} :: \mc{char}}{ExpArrSub}
						\end{align*}
					\item
						\begin{align*}
							\drmrule{S\ruleapp{E}\mc{e}::\mc{[t]}\ \ S\ruleapp{E}\mc{i}::\mc{int}}{S}{E}{\mc{e[i]} :: \mc{t}}{ExpArrSub}
						\end{align*}
				\end{itemize}
			
			\subsubsection{Projection}
			
				\begin{align*}
					\drmrule{(\mc{f},\mc{t},\_)\in S_{\mc{Id}}}{S}{E}{\mc{Id.f}::\mc{t}}{ExpProjModule}
				\end{align*}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{e}::\mc{[t]}}{S}{E}{\mc{e.length} :: \mc{int}}{ExpProjListLength}
				\end{align*}
			
			\subsubsection{Comparison Lists}
			
				\begin{align*}
					\drmrule{\ruleapp{O}\mc{op1}::\mc{(t0,t1)->t},\ \dots,\ \ruleapp{O}\mc{opn}::\mc{(t(n-1),tn)->t}\ \ S\ruleapp{ET} (\mc{e0},\dots,\mc{en}) [\trianglelefteq|\bowtie] (\mc{t0},\dots,\mc{tn})}{S}{E}{\mc{e0 op1 ... opn en} :: \mc{t}}{ExpCmpList}
				\end{align*}
				
		\subsection{Statements}
		
			In the statement typing rules, a statement rule produces a tuple $(S,r)$ where $S$ stands for the newly updated context, and $r\in\{\bot,\top\}$, where $\bot$ means that a statement might not return and $\top$ means that a statement definitely returns.
			
			To prevent potential mistakes, the typechecker prevents statements which are deemed unreachable at compile time. The logical operators $\vee$ and $\wedge$ operate as if $\bot\equiv0$ and $\top\equiv1$. A statement creates two such items, one for unreachability due to a \code{return}; one due to a \code{break}/\code{continue} statement. The difference is necessary due to different treatment after the loop body in a \code{do-while} statement.
			
			The $\top$ or $\bot$ on the LHS of a statement represents whether the current statement is in a block or not (this determines whether \code{break}/\code{continue} statements are applicable).
		
			\subsubsection{Local Variable Declarations}
			
				\begin{align*}
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{E}\mc{exp} :: \mc{t}}{S,T,\mc{rt},L}{S}{\mc{let id := exp} \Rightarrow (S \cup (\mc{id},\mc{t},c)),\bot}{StmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ T\ruleapp{D}\mc{t}\ \  S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{t}\vee\mc{exp}\bowtie\mc{t}}{S,T,\mc{rt},L}{S}{\mc{let id:t := exp} \Rightarrow (S \cup (\mc{id},\mc{t},c)),\bot}{StmtVTDeclConst}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ S\ruleapp{E}\mc{exp} :: \mc{t}}{S,T,\mc{rt},L}{S}{\mc{mut id := exp} \Rightarrow (S \cup (\mc{id},\mc{t},m)),\bot}{StmtVDeclMut}\\
					\drmrule{(\mc{id},\_,\_)\not\in_0 S\ \ T\ruleapp{D}\mc{t}\ \  S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{t}\vee\mc{exp}\bowtie\mc{t}}{S,T,\mc{rt},L}{S}{\mc{mut id:t := exp} \Rightarrow (S \cup (\mc{id},\mc{t},m)),\bot}{StmtVTDeclMut}
				\end{align*}
			
			\subsubsection{Assignments}
			
				\begin{align*}
					\drmrule{S\ruleapp{A}\mc{lhs}\ \ S\ruleapp{E}\mc{lhs} :: \mc{t}\ \ S\ruleapp{ET}\mc{exp} \trianglelefteq \mc{t} \vee \mc{exp}\bowtie\mc{t}}{S,T,\mc{rt},L}{S}{\mc{lhs := exp} \Rightarrow S,\bot,\bot}{StmtAssn}
				\end{align*}
			
			\subsubsection{Expression Statements}
			
				This rule allows \code{void} return types for functions for the first rule application in the proof tree above.
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp} :: \mc{t}}{S,\mc{rt}}{S}{\mc{exp} \Rightarrow S,\bot}{StmtExpr}
				\end{align*}
				
			\subsubsection{\code{printf} Call}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{sprintf("...\{j1\}...\{jm\}...", e1,...,en)}::\mc{string}}{S,T,\mc{rt},L}{S}{\mc{printf("...\{j1\}...\{jm\}...", e1,...,en)} \Rightarrow S,\bot,\bot}{StmtPrintf}
				\end{align*}
				
			\subsubsection{\code{assert} Call}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{bool}}{S,T,\mc{rt},L}{S}{\mc{assert exp}\Rightarrow S,\bot}{StmtAssert}
				\end{align*}
			
			\subsubsection{If Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,T,\mc{rt},L\ruleapp{S}\mc{b1}\Rightarrow S_1,R_1,B_1\ \ S,T,\mc{rt},L\ruleapp{S}\mc{b2}\Rightarrow S_2,R_2,B_2}{S,T,\mc{rt},L}{S}{\mc{if c b1 else b2} \Rightarrow S,R_1\wedge R_2,B_1\wedge B_2}{StmtIf}
				\end{align*}
				
			\subsubsection{Checked Null Casts}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{t?}\ \ S\cup\{(\mc{r},\mc{t},c)\},T,\mc{rt},L \ruleapp{S} \mc{b1} \Rightarrow S',R_1,B_2\ \ S,T,\mc{rt},L \ruleapp{S}\mc{b2}\Rightarrow S'',R_2,B_2}{S,T,\mc{rt},L}{S}{\mc{denull r := exp b1 else b2} \Rightarrow S,R_1\wedge R_2,B_1\wedge B_2}{StmtNullCast}
				\end{align*}
			
			\subsubsection{While Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,T,\mc{rt},\top\ruleapp{S}\mc{b}\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{while c b} \Rightarrow S,\bot,\bot}{StmtWhile}
				\end{align*}
			
			\subsubsection{Do-While Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{c} :: \mc{bool}\ \ S,T,\mc{rt},\top\ruleapp{S}\mc{b}\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{do b while c} \Rightarrow S,R,\bot}{StmtDoWhile}
				\end{align*}
				
			\subsubsection{For Statements}
	
				\begin{align*}
					\drmrule{S\ruleapp{E}\mc{estart}::\mc{int}\ \ S\ruleapp{E}\mc{eend}::\mc{int}\ \ S\cup \{ (\mc{id},\mc{int},c) \},T,\mc{rt},\top\ruleapp{S} \mc{b}\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{for id := estart \%RangeSpecifier eend b} \Rightarrow S,\bot,\bot}{StmtFor}
				\end{align*}\begin{align*}
					\drmrule{S\ruleapp{E}\mc{exp}::\mc{[t]}\ \ S\cup\{(\mc{id},\mc{t},c)\},T,\mc{rt},\top\ruleapp{S}b\Rightarrow S',R,B}{S,T,\mc{rt},L}{S}{\mc{for id in exp b} \Rightarrow S,\bot,\bot}{StmtForIn}
				\end{align*}
				
			\subsubsection{Break and Continue}
			
				\begin{align*}
					\drmrule{}{S,T,\mc{rt},\top}{S}{\mc{break} \Rightarrow S,\bot,\top}{StmtBreak},\ \ 
					\drmrule{}{S,T,\mc{rt},\top}{S}{\mc{continue} \Rightarrow S,\bot,\top}{StmtContinue}
				\end{align*}
			
			\subsubsection{Return Statements}
			
				\begin{align*}
					\drmrule{S\ruleapp{ET}\mc{exp}\trianglelefteq\mc{rt}\vee\mc{exp}\bowtie\mc{rt}}{S,\mc{rt}}{S}{\mc{return exp} \Rightarrow S,\top}{StmtReturnExp},\ \  \drmrule{}{S,T,\mc{void},L}{S}{\mc{return}\Rightarrow S,\top,\bot}{StmtReturn}
				\end{align*}
				
			\subsubsection{Blocks}
			
				\begin{align*}
					\drmrule{S\sqcup\{\},\mc{rt},L\ruleapp{S}\mc{s1} \Rightarrow S_1,\bot,\bot\ \ S_1,T,\mc{rt},L\ruleapp{S}\mc{s2} \Rightarrow S_2,\bot,\bot,\ \dots,\ S_{n-1},\mc{rt},L\ruleapp{S}\mc{sn} \Rightarrow S_n,R,B}{S,\mc{rt},L}{S}{\mc{s1 ... sn} \Rightarrow S_n,R,B}{StmtBlock}
				\end{align*}
		
		\subsection{Global Statements}
		
			\subsubsection{Global Function Declaration}
			
				\begin{align*}
					\drmrule{T\ruleapp{D}\mc{t1},\dots,T\ruleapp{D}\mc{tn},T\ruleapp{D}\mc{rt}\ \ S\sqcup\{(\mc{a1},\mc{t1},c),\dots,(\mc{an},\mc{tn},c)\},T,\mc{rt},\bot\ruleapp{S} \mc{b} \Rightarrow S',\top,\bot\;(\textnormal{or \code{rt=void}}) \ \ \mc{a1},\dots,\mc{an} \textnormal{ distinct}}{S,T}{G}{\mc{fn id : a1:t1, ..., an:tn -> rt b} \Rightarrow S,T}{GStmtFDecl}
				\end{align*}
			
			\subsubsection{Global Variable Declaration}
			
				\begin{align*}
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{G}\mc{exp} :: \mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global id := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\},T}{GStmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ T\ruleapp{D}\mc{t}\ \ S\ruleapp{GT}\mc{exp}\trianglelefteq\mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global id:t := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\},T}{GStmtVDeclConst}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ S\ruleapp{G}\mc{exp} :: \mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global mut id := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},m)\},T}{GStmtVDeclMut}\\
					\drmrule{(\mc{id},\_,\_) \not\in S\ \ T\ruleapp{D}\mc{t}\ \ S\ruleapp{GT}\mc{exp}\trianglelefteq\mc{t}\ \ \mc{t}\textnormal{ non-\code{null}}}{S,T}{G}{\mc{global mut id:t := exp} \Rightarrow S\cup\{(\mc{id},\mc{t},m)\},T}{GStmtVDeclMut}
				\end{align*}
				
			\subsubsection{Native Declarations}
			
				\begin{align*}
					\drmrule{\mc{t}\not\in T}{S,T}{G}{\mc{native type t} \Rightarrow S,T\cup\{\mc{t}\}}{GStmtNativeTDecl}\\
					\drmrule{}{S,T}{G}{\mc{native fn f: t1,...,tn -> rt} \Rightarrow S,T}{GStmtNativeFDecl}\\
					\drmrule{(\mc{id},\_,\_)\not\in S}{S,T}{G}{\mc{native t id} \Rightarrow S\cup\{(\mc{id},\mc{t},c)\},T}{GStmtNativeVDecl}
				\end{align*}
				
			\subsubsection{Module Header}
			
				\begin{align*}
					\drmrule{}{S,T}{G}{\mc{module M} \Rightarrow S \textnormal{ where $S_{\mc{M}} = S$ with \code{M} as the only active module},T}{GStmtModule}
				\end{align*}
			
			\subsubsection{Program}
			
				\begin{align*}
					\drmrule{S_0,T_0 \ruleapp{G} \mc{gs1} \Rightarrow S_1,T_1\ \dots,\ S_{n-1},T_{n-1} \ruleapp{G} \mc{gsn} \Rightarrow S_n,T_n}{S_0,T_0}{G}{\mc{gs1 ... gsn} \Rightarrow S_n,T_n}{GStmtProgram}
				\end{align*}
				
		\subsection{Context Buildup}
		
			\subsubsection{Global Function Declarations}
			
				\begin{align*}
					\drmrule{(\mc{id},\_) \not\in S}{S,T}{GCF}{\mc{fn id : a1:t1, ..., an:tn -> rt b} \Rightarrow S \cup \{(\mc{id}, \mc{(t1,...,tn)->rt}, c)\},T}{GStmtFCtxtFDecl}\\
					\drmrule{(\mc{id},\_) \not\in S}{S,T}{GCF}{\mc{native fn f : t1,...,tn -> rt} \Rightarrow S \cup \{(\mc{id}, \mc{(t1,...,tn)->rt}, c)\},T}{GStmtFCtxtNFDecl}
				\end{align*}\begin{align*}
					\drmrule{}{S,T}{GCF}{\mc{global X := Y} \Rightarrow S,T}{GStmtFCtxtVDecl}\\
					\drmrule{}{S,T}{GCF}{\mc{native type T} \Rightarrow S,T}{GStmtFCtxtNTDecl}\\
					\drmrule{}{S,T}{GCF}{\mc{native t id} \Rightarrow S,T}{GStmtFCtxtNVDecl}
				\end{align*}\begin{align*}
					\drmrule{}{S,T}{GCF}{\mc{module M} \Rightarrow S\textnormal{ where $S_{\mc{M}} = S$ with \code{M} as the only active module}, T}{GStmtFCtxtModule}
				\end{align*}
			
			\subsubsection{Program: Functions}
			
				\begin{align*}
					\drmrule{S_0,T_0 \ruleapp{GCF} \mc{gs1} \Rightarrow S_1,T_1,\ \dots,\ S_{n-1},T_{n-1} \ruleapp{GCF} \mc{gsn} \Rightarrow S_n,T_n}{S_0,T_0}{GC}{\mc{gs1 ... gsn} \Rightarrow S_n,T_n \textnormal{ with no active module}}{GStmtCtxtFuncs}
				\end{align*}
			
		\subsection{Rule for Program Typechecking}
		
			Let $S^\star$ be the starting context which contains the builtin context. It looks as follows:
			
			\begin{align*}
				S^\star := \{\}\sqcup \left\{ (\mc{id}, \mathsf{t}, c) \ \mid\ \mc{id}\textnormal{ is builtin with type \textsf{t}} \right\}
			\end{align*}
			
			Let $\mathsf{maintys}$ be the legal set of types of main functions -- one of which must be contained in a program.
			
			\begin{align*}
				\mathsf{maintys} := \left\{
					\begin{array}{ll}
						\mc{void -> void}, & \mc{void -> int},\\
						\mc{[string] -> void}, & \mc{[string] -> int}
					\end{array}
				\right\}
			\end{align*}
		
			Then, the program rule \textsc{Prog} shall be:
		
			\begin{align*}
				\drmrule{S^\star,\emptyset \ruleapp{GC} \mc{prog} \Rightarrow S',T_0 \ \ \exists!\; \mc{ft}\in\mathsf{maintys}:\;(\mc{main},\mc{ft},c)\in S'\ \ S',T_0 \ruleapp{G} \mc{prog} \Rightarrow S,T_1}{}{}{\mc{prog}}{Prog}
			\end{align*}
		
	\section{Formal Grammar}
	
		\subsection{Lexer Grammar}
		
			The Lexer Grammar is specified using \textbf{regular expressions}:
			
			\begin{small}\begin{verbatim}
				LiteralInt   ::= /[1-9]\d*/
				LiteralFlt   ::= /\d+\.\d+/
				LiteralChar  ::= /'([^'\\]|(\\[\\nrt']))'/
				LiteralBool  ::= /true|false/
				LiteralStr   ::= /"([^"\\]|(\\[\\nrt"]))*"/
				
				Identifier   ::= /[a-zA-Z][a-zA-Z0-9_]*/
				
				module       ::= /module/
				native       ::= /native/
				
				global       ::= /global/
				fn           ::= /fn/
				let          ::= /let/
				mut          ::= /mut/
				
				type         ::= /type/
				int          ::= /int/
				flt          ::= /flt/
				char         ::= /char/
				bool         ::= /bool/
				string       ::= /string/
				void         ::= /void/
				
				null         ::= /null/
				denull       ::= /denull/
				
				of           ::= /of/
				in           ::= /in/
				
				if           ::= /if/
				elif         ::= /elif/
				else         ::= /else/
				do           ::= /do/
				while        ::= /while/
				for          ::= /for/
				
				break        ::= /break/
				continue     ::= /continue/
				
				printf       ::= /printf/
				sprintf      ::= /sprintf/
				assert       ::= /assert/
				 
				return       ::= /return/
				
				Dash         ::= /\-/
				Bang         ::= /!/
				Star         ::= /\*/
				Plus         ::= /\+/
				LShift       ::= /<</
				RShift       ::= />>/
				AShift       ::= />>>/
				Bitand       ::= /&/
				Xor          ::= /\^/
				Bitor        ::= /\|/
				Logand       ::= /&&/
				Logor        ::= /\|\|/
				
				Equal        ::= /=/
				NotEqual     ::= /!=/
				Greater      ::= />/
				Less         ::= /</
				GreaterEq    ::= />=/
				LessEq       ::= /<=/
				
				RefEqual     ::= /==/
				RefNotEqual  ::= /!==/
				
				Assign       ::= /:=/
				
				Colon        ::= /:/
				Arrow        ::= /\->/
				
				Dot          ::= /\./
				Comma        ::= /\,/
				
				Dots         ::= /\.\.\./
				DotsPipe     ::= /\.\.\|/
				PipeDots     ::= /\|\.\./
				PipeDotPipe  ::= /\|\.\|/
				
				LParen       ::= /\(/
				RParen       ::= /\)/
				LBrack       ::= /\[/
				RBrack       ::= /\]/
				
				QuestionMark ::= /\?/
			\end{verbatim}\end{small}
			
		\subsection{Parser Grammar}
		
			The following grammar specification uses a preceding \texttt{\%} for lexer tokens. In order to support human readability of the grammar, it is given in EBNF.
		
			\begin{small}\begin{verbatim}
				Program          ::= { GlobalStatement }
				                 
				GlobalStatement  ::= GVDeclaration | GFDeclaration | %Module %Identifier | %Native NatDecl
				                 
				GVDeclaration    ::=  %Global [ %Mut ] %Identifier [ %Colon Type ] %Assign GlobalExpression
				                      { %Comma %Identifier [ %Colon Type ] %Assign GlobalExpression }
				GFDeclaration    ::= %Fn %Identifier [ %LParen FArguments %Rparen ] %Arrow ReturnType Block
				NatDecl          ::=
				    %Type %Identifier | Type %Identifier
				    | %Fn %Identifier [ %LParen FArguments %RParen ] %Arrow ReturnType
				                 
				FArguments       ::= [ %Identifier %Colon Type { %Comma %Identifier %Colon Type } ]
				
				ReturnType       ::= %Void | Type
				                 
				Block            ::= { Statement }
				
				Statement        ::=
				    VDeclaration | AssignStmt
				    | IfStmt | NullCastStmt
				    | WhileStmt | DoWhileStmt | ForStmt
				    | ExprStmt
				    | %Break | %Continue
				    | ReturnStmt
				                 
				VDeclaration     ::= [ %Let | %Mut ] %Identifier [ %Colon Type ] %Assign Expression
				                     { %Comma %Identifier [ %Colon Type ] %Assign Expression }
				                 
				AssignStmt       ::= LHS %Assign Expression
				                 
				IfStmt           ::= %If Expression Block { %Elif Expression Block } [ %Else Block ]
				                 
				NullCastStmt     ::= %Denull %Id %Assign Expression Block [ %Else Block ]
				                 
				WhileStmt        ::= %While Expression Block
				DoWhileStmt      ::= %Do Block %While Expression
				ForStmt          ::=
				    %For %Id %Assign Expr RangeSpecifier Expr Block
				    | %For %Id %In Expr Block
				                 
				RangeSpecifier   ::= %Dots | %DotsPipe | %PipeDots | %PipeDotPipe
				                 
				ExprStmt         ::=
				    Expression
				    | %Printf %LParen %LiteralStr PrintfArglist %RParen
				    | %Assert Expression
				                 
				ReturnStmt       ::= %Return [ Expression ]
				                 
				LHS              ::= BaseExpression { Application }
				
				Type             ::= BaseType | FType
				FType            ::= %LParen [ Type { %Comma Type } ] %Arrow Type
				RefType          ::= %String | %LBrack Type %RBrack | %Identifier [ %Dot %Identifier ]
				BaseType         ::= %LParen (FType | RefType) %RParen %QuestionMark
				                     | %LParen Type %RParen
				                     | %Int | %Flt | %Char | %Bool
				                     | %Less %Identifier %Greater [ %QuestionMark ]          
				                 
				GlobalExpression ::= Expression
			
				Expression       ::=
				    %Null %Of RefType
				    | %LBrack %RBrack %Of Type
				    | %QuestionMark Expression %Arrow Expression %Colon Expression
 				    | %Assert Expression
				    | ExprPrec30
				
				ExprPrec20       ::=
				     ExprPrec30 [ (%Equal | %NotEqual | %Greater | %Less | %GreaterEq
				         | %LessEq | %RefEqual | %RefNotEqual) ExprPrec20 ]
				         
				ExprPrec30       ::= ExprPrec40 [ %Bitor ExprPrec30 ]
				ExprPrec40       ::= ExprPrec50 [ %Xor ExprPrec40 ]
				ExprPrec50       ::= ExprPrec60 [ %Bitand ExprPrec50 ]
				ExprPrec60       ::= ExprPrec70 [ (%LShift | %RShift | %Ashift) ExprPrec60 ]
				ExprPrec70       ::= ExprPrec80 [ (%Plus | %Minus) ExprPrec70 ]
				ExprPrec80       ::= ExprPrec90 [ %Star ExprPrec80 ]
				ExprPrec90       ::= ExprPrec100 [ %StarStar ExprPrec90 ]
				ExprPrec100      ::= SimpleExpression | (%Dash | %Bang) ExprPrec100
				                 
				SimpleExpression ::= BaseExpression { Application }
				
				BaseExpression   ::=
				    %LParen Expression %RParen
				    | %LBrack [ Expression { %Comma Expression } ] %RBrack
				    | %LBrack Expression RangeSpecifier Expression %RBrack
				    | %LBrack Expression %Colon
				        [ %Identifier %In Expression { %Comma %Identifier %In Expression } ]
				        [ %Colon Expression ] %RBrack
				    | %LiteralInt | %LiteralFlt | %LiteralChar | %LiteralBool | %LiteralStr
				    | %Identifier
				    | %Sprintf %LParen %LiteralStr
				        [ Expression { %Comma PrintfArglist } ] %RParen
				                 
				Application      ::=
				    %LParen [ FArg { %Comma FArg } ] %RParen
				    | %LBrack Expression %RBrack
				    | %Dot Identifier
				                 
				FArg             ::= Expression | %Underscore
			\end{verbatim}\end{small}
	
\end{document}






















