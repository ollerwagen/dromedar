# Dromedar Programming Language

Dromedar is a statically and strongly typed _safe_ programming language.

As of right now, the language includes primitive types, strings and arrays, fully connected to the garbage collector.
Because I am currently working on the language, it is likely that programs that work on day X stop working or change their behaviour due to a compiler update.

The [Documentation](Doc/Doc.pdf) contains extensive documentation, including a formal grammar and typing specification. The [Examples](Droml/ExamplePrograms/) folder contains some example programs with functionality that is already implemented.

## Using The Compiler

In order to compile the compiler, you will need `clang`, `make` and `ocaml` installed.

You can then compile the compiler and all the resources it requires with `make all`.

Then, you may compile `.drm` files with `./droml <filename>`. This generates an `Out.ll` file that contains the generated LLVM IR code, an `Out.s` file containing the Assembly code generated by the clang compiler using the `Out.ll` file, and finally the file `a.out`, an executable for the given input program.

## Quick Introduction

Everything described in this section is described in more detail in the [documentation](Doc/Doc.pdf). This text simply serves as a quick introduction into the language and its features.

### Hello, World!

    fn main -> void
        print_str("Hello, World!\n")

### Program Buildup

Each Dromedar program consists of a series of global function and variable declarations. Function bodies contain statements (assignments, variable declarations, if-statements, etc.).

The language uses significant whitespace. Two neighboring instructions in the same block require the same indentation string, whereas a deeper instruction requires a longer indentation string. Two blocks with the same indentation level do not necessarily need the same indentation string, but they do need to match their respective environments.

#### Function Declarations

Function declarations are created using the `fn` keyword, followed by a name, an argument list and a return type. For example, the function header `fn f : x:int, y:int -> int` declares an `int`-function, taking two `int` arguments.

Functions are accessible in the entire program, meaning that mutual recursion is possible without forward declarations.

### Typing System

Dromedar knows four primitive types: `bool`, `char`, `int` and `flt`.

The language uses a safe typing system. This means that `null` pointer errors are impossible: dereferencing a reference object is only possible if it is of a strictly non-`null` type. Reference types come in non-`null`, and maybe-`null` types, which are denoted by a `?` suffix.

#### Lists

There are three ways to write down list literals:

* As an actual list: `[1,2,3,4,5]` is the list containing the numbers from 1 to 5.
* As a bounded list: `[1...5]` is the same list. The delimiter `..|` doesn't include the last element, `|..` doesn't include the first, and `|.|` doesn't include either. Thus, `[1...5]` and `[0|.|6]` are equivalent. Bounded lists can only return `int` lists as of now, but I plan on extending them to `char` lists as well.
* As a comprehension list: `[exp : decls : condition]`, e.g. as follows: `[2*x : x in [0...10] : x > 5]`, which is equivalent to `[12,14,16,18,20]`.

### Statements

#### Declarations

The following are simple local declarations:

    let a := 3
    let b := 2.0
    let c:int := 7
    let d:flt := 6
    let e:string? := "hi!"
    let f:[[int]] := [[1,2],[3],[4,5,6]]

The type specification is optional, but it allows for some bending of the rules: Declaring a variable as `flt` and assigning it an `int` value (and vice versa), is possible - as well as assigning a variable of type `t?` a value of type `t`, as in the string declaration.

Variables are immutable, unless declared with the `mut` keyword, in which they may change the value assigned to them.

#### Control Flow

There are five control flow constructs implemented as of today: `if-elif-else`, `while`, `do-while`, `for` and `denull`. Here are semantically equivalent examples for `do-while` and `for`:

    mut i := 0
    do
        printf("{0}\n", i)
        i := i + 1
    while i < 10

    for i := 0 ..| 10
        printf("{0}\n", i)

Both these programs print the numbers from 0 to 9.

The `denull` statement checks whether an expression passed to it is `null`. If not, its result may be used as if it were of non-`null` type, as follows:

    denull x := getstring()
        print_str(x)

A `denull` statement may be followed by an `else` block which gets executed if the expression is `null`.

